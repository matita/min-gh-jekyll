---
title: My first Service Worker — Medium
description: I’ve made no secret of the fact that I’m really excited about Service Workers. I’m not alone. At the Coldfront conferenc…
link: https://medium.com/@adactio/my-first-service-worker-5e5af0b1bdbb#.yzaraog7b
saved: 2015-11-24 15:55:49
---

<h3 name="3535" id="3535" class="graf--h3 graf--first">My first Service Worker</h3><p name="5788" id="5788" class="graf--p graf-after--h3">I’ve made no secret of the fact that I’m <em class="markup--em markup--p-em">really</em> excited about <a href="http://www.html5rocks.com/en/tutorials/service-worker/introduction/" data-href="http://www.html5rocks.com/en/tutorials/service-worker/introduction/" class="markup--anchor markup--p-anchor" rel="nofollow">Service Workers</a>. I’m not alone. At <a href="https://coldfrontconf.com/" data-href="https://coldfrontconf.com/" class="markup--anchor markup--p-anchor" rel="nofollow">the Coldfront conference</a> in Copenhagen, <a href="https://adactio.com/journal/9480" data-href="https://adactio.com/journal/9480" class="markup--anchor markup--p-anchor" rel="nofollow">pretty much every talk mentioned Service Workers</a>.</p><p name="db13" id="db13" class="graf--p graf-after--p">Obviously I’m excited about what Service Workers enable: offline caching, background processes, push notifications, and all sorts of other goodies that allow the web to compete with native. But more than that, I’m really excited about the way that the Service Worker spec has been designed. Instead of being an all-or-nothing technology that you have to bet the farm on, it has been deliberately crafted to be used as an <em class="markup--em markup--p-em">enhancement</em> on top of existing sites (oh, how I wish that web components would follow a similar path).</p><p name="6c3e" id="6c3e" class="graf--p graf-after--p">I’ve got plenty of ideas on how Service Workers could be used to enhance a community site like <a href="https://thesession.org/" data-href="https://thesession.org/" class="markup--anchor markup--p-anchor" rel="nofollow">The Session</a> or the kind of <a href="http://2015.dconstruct.org/" data-href="http://2015.dconstruct.org/" class="markup--anchor markup--p-anchor" rel="nofollow">events sites</a> that we produce at <a href="http://clearleft.com/" data-href="http://clearleft.com/" class="markup--anchor markup--p-anchor" rel="nofollow">Clearleft</a>, but to begin with, I figured it would make sense to use my own personal site as a playground.</p><p name="b2e9" id="b2e9" class="graf--p graf-after--p">To start with, I’ve already conquered the first hurdle: <a href="https://adactio.com/articles/7435" data-href="https://adactio.com/articles/7435" class="markup--anchor markup--p-anchor" rel="nofollow">serving my site over HTTPS</a>. Service Workers require a secure connection. But you can play around with running a Service Worker locally if you run a copy of your site on localhost.</p><p name="b3e5" id="b3e5" class="graf--p graf-after--p">That’s how I started experimenting with Service Workers: serving on localhost, and stopping and starting my local Apache server with apachectl stop and apachectl start on the command line.</p><p name="1b9f" id="1b9f" class="graf--p graf-after--p">That reminds of another interesting use case for Service Workers: it’s not just about the user’s network connection failing (say, going into a train tunnel); it’s also about your web server not always being available. Both scenarios are covered equally.</p><p name="4362" id="4362" class="graf--p graf-after--p">I would never have even attempted to start if it weren’t for the existing examples from people who have been generous enough to share their work:</p><ul class="postList"><li name="c7b5" id="c7b5" class="graf--li graf-after--p">The Guardian Developer Blog documents <a href="https://www.theguardian.com/info/developer-blog/2015/nov/04/building-an-offline-page-for-theguardiancom" data-href="https://www.theguardian.com/info/developer-blog/2015/nov/04/building-an-offline-page-for-theguardiancom" class="markup--anchor markup--li-anchor" rel="nofollow">how they provide an offline page</a>.</li><li name="6050" id="6050" class="graf--li graf-after--li">Nicolas documented how <a href="https://ponyfoo.com/articles/serviceworker-revolution" data-href="https://ponyfoo.com/articles/serviceworker-revolution" class="markup--anchor markup--li-anchor" rel="nofollow">he set up a Service Worker for his site</a>.</li><li name="32e4" id="32e4" class="graf--li graf-after--li">Jake put together <a href="https://jakearchibald.com/2014/offline-cookbook/" data-href="https://jakearchibald.com/2014/offline-cookbook/" class="markup--anchor markup--li-anchor" rel="nofollow">an offline cookbook</a> covering the many ways that Service Workers can be used.</li></ul><p name="0a0a" id="0a0a" class="graf--p graf-after--li">Also, I knew that Jake was coming to <a href="http://2015.ffconf.org/" data-href="http://2015.ffconf.org/" class="markup--anchor markup--p-anchor" rel="nofollow">FF Conf</a> so if I got stumped, I could pester him. That’s <a href="https://adactio.com/notes/9769" data-href="https://adactio.com/notes/9769" class="markup--anchor markup--p-anchor" rel="nofollow">exactly what ended up happening</a> (thanks, Jake!).</p><p name="d3dd" id="d3dd" class="graf--p graf-after--p">So if you decide to play around with Service Workers, please, please share your experience.</p><p name="c026" id="c026" class="graf--p graf-after--p">It’s entirely up to you <em class="markup--em markup--p-em">how</em> you use Service Workers. I figured for a personal site like this, it would be nice to:</p><ol class="postList"><li name="2e9d" id="2e9d" class="graf--li graf-after--p">Explicitly cache resources like CSS, JavaScript, and some images.</li><li name="2a54" id="2a54" class="graf--li graf-after--li">Cache the homepage so it can be displayed even when the network connection fails.</li><li name="ee7d" id="ee7d" class="graf--li graf-after--li">For other pages, have a fallback “offline” page to display when the network connection fails.</li></ol><p name="b35a" id="b35a" class="graf--p graf-after--li">So now I’ve got <a href="https://adactio.com/serviceworker.js" data-href="https://adactio.com/serviceworker.js" class="markup--anchor markup--p-anchor" rel="nofollow">a Service Worker up and running on adactio.com</a>. It will only work in Chrome, Android, Opera, and the forthcoming version of Firefox&nbsp;…and that’s just fine. It’s an enhancement. As more and more browsers start supporting it, this Service Worker will become more and more useful.</p><p name="ee47" id="ee47" class="graf--p graf-after--p">How very <a href="http://futurefriendlyweb.com/" data-href="http://futurefriendlyweb.com/" class="markup--anchor markup--p-anchor" rel="nofollow">future friendly</a>!</p><h4 name="4447" id="4447" class="graf--h4 graf-after--p">The code</h4><p name="0210" id="0210" class="graf--p graf-after--h4">If you’re interested in the nitty-gritty of what <a href="https://adactio.com/serviceworker.js" data-href="https://adactio.com/serviceworker.js" class="markup--anchor markup--p-anchor" rel="nofollow">my Service Worker</a> is doing, read on. If, on the other hand, code is not your bag, now would be a good time to bow out.</p><p name="55a9" id="55a9" class="graf--p graf-after--p">If you want to jump straight to the finished code, <a href="https://gist.github.com/adactio/fbaa3a5952774553f5e7" data-href="https://gist.github.com/adactio/fbaa3a5952774553f5e7" class="markup--anchor markup--p-anchor" rel="nofollow">here’s a gist</a>. Feel free to take it, break it, copy it, improve it, or do anything else you want with it.</p><p name="0530" id="0530" class="graf--p graf-after--p">To start with, let’s establish exactly what a Service Worker is. I like <a href="http://www.html5rocks.com/en/tutorials/service-worker/introduction/" data-href="http://www.html5rocks.com/en/tutorials/service-worker/introduction/" class="markup--anchor markup--p-anchor" rel="nofollow">this definition by Matt Gaunt</a>:</p><blockquote name="2bc3" id="2bc3" class="graf--blockquote graf-after--p">A service worker is a script that is run by your browser in the background, separate from a web page, opening the door to features which don’t need a web page or user interaction.</blockquote><h4 name="2137" id="2137" class="graf--h4 graf-after--blockquote">register</h4><p name="5bac" id="5bac" class="graf--p graf-after--h4">From inside <a href="https://adactio.com/includes/javascript/global.js" data-href="https://adactio.com/includes/javascript/global.js" class="markup--anchor markup--p-anchor" rel="nofollow">my site’s global JavaScript file</a> — or I could do this from a script element inside my pages — I’m going to do a quick bit of feature detection for Service Workers. If the browser supports it, then I’m going register my Service Worker by pointing to another JavaScript file, which sits at the root of my site:</p><pre name="750b" id="750b" class="graf--pre graf-after--p">if (navigator.serviceWorker) {<br>  navigator.serviceWorker.register('/serviceworker.js', {<br>    scope: '/'<br>  });<br>}</pre><p name="65f2" id="65f2" class="graf--p graf-after--pre">The serviceworker.js file sits in the root of my site so that it can act on any requests to my domain. If I put it somewhere like /js/serviceworker.js, then it would only be able to act on requests to the /js directory.</p><p name="1a2f" id="1a2f" class="graf--p graf-after--p">Once that file has been loaded, the installation of the Service Worker can begin. That means the script will be installed in the user’s browser&nbsp;…and it will live there even after the user has left my website.</p><h4 name="363f" id="363f" class="graf--h4 graf-after--p">install</h4><p name="49d9" id="49d9" class="graf--p graf-after--h4">I’m making the installation of the Service Worker dependent on a function called updateStaticCache that will populate a cache with the files I want to store:</p><pre name="d9bb" id="d9bb" class="graf--pre graf-after--p">self.addEventListener('install', function (event) {<br>  event.waitUntil(updateStaticCache());<br>});</pre><p name="0b18" id="0b18" class="graf--p graf-after--pre">That updateStaticCache function will be used for storing items in a cache. I’m going to make sure that the cache has a version number in its name, exactly <a href="https://www.theguardian.com/info/developer-blog/2015/nov/04/building-an-offline-page-for-theguardiancom" data-href="https://www.theguardian.com/info/developer-blog/2015/nov/04/building-an-offline-page-for-theguardiancom" class="markup--anchor markup--p-anchor" rel="nofollow">as described in the Guardian’s use case</a>. That way, when I want to update the cache, I only need to update the version number.</p><pre name="9037" id="9037" class="graf--pre graf-after--p">var staticCacheName = 'static';<br>var version = 'v1::';</pre><p name="04b0" id="04b0" class="graf--p graf-after--pre">Here’s the updateStaticCache function that puts the items I want into the cache. I’m storing my JavaScript, my CSS, some images referenced in the CSS, the home page of my site, and a page for displaying when offline.</p><pre name="04df" id="04df" class="graf--pre graf-after--p">function updateStaticCache() {<br>  return caches.open(version + staticCacheName)<br>    .then(function (cache) {<br>      return cache.addAll([<br>        '/path/to/javascript.js',<br>        '/path/to/stylesheet.css',<br>        '/path/to/someimage.png',<br>        '/path/to/someotherimage.png',<br>        '/',<br>        '/offline'<br>      ]);<br>    });<br>};</pre><p name="131c" id="131c" class="graf--p graf-after--pre">Because those items are part of the return statement for the Promise created by caches.open, the Service Worker won’t install until all of those items are in the cache. So you might want to keep them to a minimum.</p><p name="df5e" id="df5e" class="graf--p graf-after--p">You can still put other items in the cache, and not make them part of the return statement. That way, they’ll get added to the cache in their own good time, and the installation of the Service Worker won’t be delayed:</p><pre name="fa13" id="fa13" class="graf--pre graf-after--p">function updateStaticCache() {<br>  return caches.open(version + staticCacheName)<br>    .then(function (cache) {<br>      cache.addAll([<br>        '/path/to/somefile',<br>        '/path/to/someotherfile'<br>      ]);<br>      return cache.addAll([<br>        '/path/to/javascript.js',<br>        '/path/to/stylesheet.css',<br>        '/path/to/someimage.png',<br>        '/path/to/someotherimage.png',<br>        '/',<br>        '/offline'<br>      ]);<br>    });<br>}</pre><p name="e39d" id="e39d" class="graf--p graf-after--pre">Another option is to use completely different caches, but I’ve decided to just use one cache for now.</p><h4 name="0042" id="0042" class="graf--h4 graf-after--p">activate</h4><p name="66fc" id="66fc" class="graf--p graf-after--h4">When the activate event fires, it’s a good opportunity to clean up any caches that are out of date (by looking for anything that doesn’t match the current version number). I copied this <a href="https://ponyfoo.com/articles/serviceworker-revolution" data-href="https://ponyfoo.com/articles/serviceworker-revolution" class="markup--anchor markup--p-anchor" rel="nofollow">straight from Nicolas’s code</a>:</p><pre name="e1eb" id="e1eb" class="graf--pre graf-after--p">self.addEventListener('activate', function (event) {<br>  event.waitUntil(<br>    caches.keys()<br>      .then(function (keys) {<br>        return Promise.all(keys<br>          .filter(function (key) {<br>            return key.indexOf(version) !== 0;<br>          })<br>          .map(function (key) {<br>            return caches.delete(key);<br>          })<br>        );<br>      })<br>  );<br>});</pre><h4 name="b7bc" id="b7bc" class="graf--h4 graf-after--pre">fetch</h4><p name="98ef" id="98ef" class="graf--p graf-after--h4">The fetch event is fired every time the browser is going to request a file from my site. The magic of Service Worker is that I can intercept that request before it happens and decide what to do with it:</p><pre name="433e" id="433e" class="graf--pre graf-after--p">self.addEventListener('fetch', function (event) {<br>  var request = event.request;<br>  ...<br>});</pre><h4 name="02b8" id="02b8" class="graf--h4 graf-after--pre">POST requests</h4><p name="4722" id="4722" class="graf--p graf-after--h4">For a start, I’m going to just back off from any requests that aren’t GET requests:</p><pre name="dd5a" id="dd5a" class="graf--pre graf-after--p">if (request.method !== 'GET') {<br>  event.respondWith(<br>      fetch(request, { credentials: 'include' })<br>  );<br>  return;<br>}</pre><p name="12ac" id="12ac" class="graf--p graf-after--pre">That’s basically just replicating what the browser would do anyway. But even here I could decide to fall back to my offline page if the request doesn’t succeed. I do that using a catch clause appended to the fetch statement:</p><pre name="0461" id="0461" class="graf--pre graf-after--p">if (request.method !== 'GET') {<br>  event.respondWith(<br>      fetch(request, { credentials: 'include' })<br>          .catch(function () {<br>              return caches.match('/offline');<br>          })<br>  );<br>  return;<br>}</pre><h4 name="2664" id="2664" class="graf--h4 graf-after--pre">HTML requests</h4><p name="91be" id="91be" class="graf--p graf-after--h4">I’m going to treat requests for pages differently to requests for files. If the browser is requesting a page, then here’s the order I want:</p><ol class="postList"><li name="9e33" id="9e33" class="graf--li graf-after--p">Try fetching the page from the network first.</li><li name="1403" id="1403" class="graf--li graf-after--li">If that doesn’t work, try looking for the page in the cache.</li><li name="5063" id="5063" class="graf--li graf-after--li">If all else fails, show the offline page.</li></ol><p name="5b9d" id="5b9d" class="graf--p graf-after--li">First of all, I need to test to see if the request is for an HTML document. I’m doing this by sniffing the Accept headers, which probably isn’t the safest method:</p><pre name="6193" id="6193" class="graf--pre graf-after--p">if (request.headers.get('Accept').indexOf('text/html') !== -1) {</pre><p name="385e" id="385e" class="graf--p graf-after--pre">Now I try to fetch the page from the network:</p><pre name="073c" id="073c" class="graf--pre graf-after--p">event.respondWith(<br>  fetch(request)<br>);</pre><p name="934a" id="934a" class="graf--p graf-after--pre">If the network is working fine, that will return the response from the site and I’ll pass that along.</p><p name="87c9" id="87c9" class="graf--p graf-after--p">But if that doesn’t work, I’m going to look for a match in the cache. Time for a catch clause:</p><pre name="76e3" id="76e3" class="graf--pre graf-after--p">.catch(function () {<br>  return caches.match(request)<br>})</pre><p name="4ce6" id="4ce6" class="graf--p graf-after--pre">So now the whole event.respondWith statement looks like this:</p><pre name="c91a" id="c91a" class="graf--pre graf-after--p">event.respondWith(<br>  fetch(request)<br>    .catch(function () {<br>      return caches.match(request);<br>    })<br>);</pre><p name="e0c1" id="e0c1" class="graf--p graf-after--pre">Finally, I need to take care of the situation when the page can’t be fetched from the network <em class="markup--em markup--p-em">and</em> it can’t be found in the cache.</p><p name="9040" id="9040" class="graf--p graf-after--p">Now, I first tried to do this by adding a catch clause to the caches.match statement, like this:</p><pre name="ffc3" id="ffc3" class="graf--pre graf-after--p">return caches.match(request)<br>  .catch(function () {<br>    return caches.match('/offline');<br>  })</pre><p name="5f79" id="5f79" class="graf--p graf-after--pre">That didn’t work and for the life of me, I couldn’t figure out why. Then <a href="https://jakearchibald.com/" data-href="https://jakearchibald.com/" class="markup--anchor markup--p-anchor" rel="nofollow">Jake</a> set me straight. It turns out that caches.match will <em class="markup--em markup--p-em">always</em> return a response&nbsp;…even if that response is undefined. So a catch clause will never be triggered. Instead I need to return the offline page if the response from the cache is falsey:</p><pre name="625b" id="625b" class="graf--pre graf-after--p">return caches.match(request)<br>  .then(function (response) {<br>    return response || caches.match('/offline');<br>  })</pre><p name="3f5f" id="3f5f" class="graf--p graf-after--pre">With that cleared up, my code for handing HTML requests looks like this:</p><pre name="0973" id="0973" class="graf--pre graf-after--p">event.respondWith(<br>  fetch(request)<br>    .catch(function () {<br>      return caches.match(request)<br>        .then(function (response) {<br>          return response || caches.match('/offline');<br>        })<br>    })<br>);</pre><p name="92d8" id="92d8" class="graf--p graf-after--pre">Actually, there’s one more thing I’m doing with HTML requests. If the network request succeeds, I stash the response in the cache.</p><p name="71d7" id="71d7" class="graf--p graf-after--p">Well, that’s not <em class="markup--em markup--p-em">exactly</em> true. I stash a <strong class="markup--strong markup--p-strong">copy</strong> of the response in the cache. That’s because you’re only allowed to read the value of a response once. So if I want to do anything with it, I have to clone it:</p><pre name="dcc8" id="dcc8" class="graf--pre graf-after--p">var copy = response.clone();<br>caches.open(version + staticCacheName)<br>  .then(function (cache) {<br>    cache.put(request, copy);<br>  });</pre><p name="ad40" id="ad40" class="graf--p graf-after--pre">I do that right before returning the actual response. Here’s how it fits together:</p><pre name="74ab" id="74ab" class="graf--pre graf-after--p">if (request.headers.get('Accept').indexOf('text/html') !== -1) {<br>  event.respondWith(<br>    fetch(request)<br>      .then(function (response) {<br>        var copy = response.clone();<br>        caches.open(version + staticCacheName)<br>          .then(function (cache) {<br>            cache.put(request, copy);<br>          });<br>        return response;<br>      })<br>      .catch(function () {<br>        return caches.match(request)<br>          .then(function (response) {<br>            return response || caches.match('/offline');<br>          })<br>      })<br>  );<br>  return;<br>}</pre><p name="1324" id="1324" class="graf--p graf-after--pre">Okay. So that’s requests for pages taken care of.</p><h4 name="3191" id="3191" class="graf--h4 graf-after--p">File requests</h4><p name="f792" id="f792" class="graf--p graf-after--h4">I want to handle requests for files differently to requests for pages. Here’s my list of priorities:</p><ol class="postList"><li name="5a5e" id="5a5e" class="graf--li graf-after--p">Look for the file in the cache first.</li><li name="cc80" id="cc80" class="graf--li graf-after--li">If that doesn’t work, make a network request.</li><li name="f7dc" id="f7dc" class="graf--li graf-after--li">If all else fails, and it’s a request for an image, show a placeholder.</li></ol><p name="e0c9" id="e0c9" class="graf--p graf-after--li">Step one: try getting the file from the cache:</p><pre name="16fd" id="16fd" class="graf--pre graf-after--p">event.respondWith(<br>  caches.match(request)<br>);</pre><p name="0620" id="0620" class="graf--p graf-after--pre">Step two: if that didn’t work, go out to the network. Now remember, I can’t use a catch clause here, because caches.match will always return something: either a response or undefined. So here’s what I do:</p><pre name="6813" id="6813" class="graf--pre graf-after--p">event.respondWith(<br>  caches.match(request)<br>    .then(function (response) {<br>      return response || fetch(request);<br>    })<br>);</pre><p name="ebd8" id="ebd8" class="graf--p graf-after--pre">Now that I’m back to dealing with a fetch, I <em class="markup--em markup--p-em">can</em> use a catch clause to take care of the third and final step: if the network request doesn’t succeed, check to see if the request was for an image, and if so, display a placeholder:</p><pre name="c9df" id="c9df" class="graf--pre graf-after--p">.catch(function () {<br>  if (request.headers.get('Accept').indexOf('image') !== -1) {<br>    return new Response('&lt;svg&gt;...&lt;/svg&gt;',  { headers: { 'Content-Type': 'image/svg+xml' }});<br>  }<br>})</pre><p name="f8b4" id="f8b4" class="graf--p graf-after--pre">I could point to a placeholder image in the cache, but I’ve decided to send an SVG on the fly using a new Response object.</p><p name="4ce1" id="4ce1" class="graf--p graf-after--p">Here’s how the whole thing looks:</p><pre name="d319" id="d319" class="graf--pre graf-after--p">event.respondWith(<br>  caches.match(request)<br>    .then(function (response) {<br>      return response || fetch(request)<br>        .catch(function () {<br>          if (request.headers.get('Accept').indexOf('image') !== -1) {<br>            return new Response('&lt;svg&gt;...&lt;/svg&gt;', { headers: { 'Content-Type': 'image/svg+xml' }});<br>          }<br>        })<br>    })<br>);</pre><p name="e652" id="e652" class="graf--p graf-after--pre">The overall shape of my code to handle fetch events now looks like this:</p><pre name="9d4f" id="9d4f" class="graf--pre graf-after--p">self.addEventListener('fetch', function (event) {<br>  var request = event.request;<br>  // Non-GET requests<br>  if (request.method !== 'GET') {<br>    event.respondWith(<br>      ... <br>    );<br>    return;<br>  }<br>  // HTML requests<br>  if (request.headers.get('Accept').indexOf('text/html') !== -1) {<br>    event.respondWith(<br>      ...<br>    );<br>    return;<br>  }<br>  // Non-HTML requests<br>  event.respondWith(<br>    ...<br>  );<br>});</pre><p name="714f" id="714f" class="graf--p graf-after--pre">Feel free to <a href="https://gist.github.com/adactio/fbaa3a5952774553f5e7" data-href="https://gist.github.com/adactio/fbaa3a5952774553f5e7" class="markup--anchor markup--p-anchor" rel="nofollow">peruse the code</a>.</p><h4 name="7539" id="7539" class="graf--h4 graf-after--p">Next steps</h4><p name="13aa" id="13aa" class="graf--p graf-after--h4">The code I’m running now is fine for a first stab, but there’s room for improvement.</p><p name="0f4d" id="0f4d" class="graf--p graf-after--p">Right now I’m stashing any HTML pages the user visits into the cache. I don’t <em class="markup--em markup--p-em">think</em> that will get out of control — I imagine most people only ever visit just a handful of pages on my site. But there’s the chance that the cache could get quite bloated. Ideally I’d have some way of keeping the cache nice and lean.</p><p name="6011" id="6011" class="graf--p graf-after--p">I was thinking: maybe I should have a separate cache for HTML pages, and limit the number in that cache to, say, 20 or 30 items. Every time I push something new into that cache, I could pop the oldest item out.</p><p name="f182" id="f182" class="graf--p graf-after--p">I could imagine doing something similar for images: keeping a cache of just the most recent 10 or 20.</p><p name="b2b7" id="b2b7" class="graf--p graf-after--p">If you fancy having a go at coding that up, let me know.</p><h4 name="1713" id="1713" class="graf--h4 graf-after--p">Lessons learned</h4><p name="4d55" id="4d55" class="graf--p graf-after--h4">There were a few gotchas along the way. I already mentioned the fact that caches.match will always return something so you can’t use catch clauses to handle situations where a file isn’t found in the cache.</p><p name="7edf" id="7edf" class="graf--p graf-after--p">Something else worth noting is that this:</p><pre name="9318" id="9318" class="graf--pre graf-after--p">fetch(request);</pre><p name="e737" id="e737" class="graf--p graf-after--pre">…is functionally equivalent to this:</p><pre name="8c19" id="8c19" class="graf--pre graf-after--p">fetch(request)<br>  .then(function (response) {<br>    return response;<br>  });</pre><p name="485a" id="485a" class="graf--p graf-after--pre">That’s probably obvious but it took me a while to realise. Likewise:</p><pre name="d936" id="d936" class="graf--pre graf-after--p">caches.match(request);</pre><p name="7389" id="7389" class="graf--p graf-after--pre">…is the same as:</p><pre name="56a0" id="56a0" class="graf--pre graf-after--p">caches.match(request)<br>  .then(function (response) {<br>    return response;<br>  });</pre><p name="1889" id="1889" class="graf--p graf-after--pre">Here’s another thing… you’ll notice that sometimes I’ve used:</p><pre name="18b3" id="18b3" class="graf--pre graf-after--p">fetch(request);</pre><p name="95aa" id="95aa" class="graf--p graf-after--pre">…but sometimes I’ve used:</p><pre name="d1d6" id="d1d6" class="graf--pre graf-after--p">fetch(request, { credentials: 'include' } );</pre><p name="1d8e" id="1d8e" class="graf--p graf-after--pre">That’s because, by default, a fetch request doesn’t include cookies. That’s fine if the request is for a static file, but if it’s for a potentially-dynamic HTML page, you probably want to make sure that the Service Worker request is no different from a regular browser request. You can do that by passing through that second (optional) argument.</p><p name="c0bf" id="c0bf" class="graf--p graf-after--p">But probably the trickiest thing is getting your head around the idea of <a href="http://www.html5rocks.com/en/tutorials/es6/promises/" data-href="http://www.html5rocks.com/en/tutorials/es6/promises/" class="markup--anchor markup--p-anchor" rel="nofollow">Promises</a>. Writing JavaScript is generally a fairly procedural affair, but once you start dealing with then clauses, you have to come to grips with the facct that the contents of those clauses will return asynchronously. So statements written <em class="markup--em markup--p-em">after</em> the then clause will probably execute <em class="markup--em markup--p-em">before</em> the code inside the clause. It’s kind of hard to explain, but if you find problems with your Service Worker code, check to see if that’s the cause.</p><p name="1434" id="1434" class="graf--p graf-after--p">And remember, please share <em class="markup--em markup--p-em">your</em> code and <em class="markup--em markup--p-em">your</em> gotchas: it’s early days for Service Workers so every implementation counts.</p><h4 name="dcad" id="dcad" class="graf--h4 graf-after--p">Updates</h4><p name="b9bc" id="b9bc" class="graf--p graf-after--h4">I got some very useful feedback from Jake after I published this…</p><p name="5931" id="5931" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Expires headers</strong></p><p name="ec26" id="ec26" class="graf--p graf-after--p">By default, JavaScript files on my server are cached for a month. But a Service Worker script probably shouldn’t be cached at all (or cached for a very, very short time). I’ve updated my&nbsp;.htaccess rules accordingly:</p><pre name="3b4c" id="3b4c" class="graf--pre graf-after--p">&lt;FilesMatch "serviceworker.js"&gt;<br>  ExpiresDefault "now"<br>&lt;/FilesMatch&gt;</pre><p name="3d33" id="3d33" class="graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Credentials</strong></p><p name="07cd" id="07cd" class="graf--p graf-after--p">If a request is initiated by the browser, I don’t need to say:</p><pre name="327e" id="327e" class="graf--pre graf-after--p">fetch(request, { credentials: 'include' } );</pre><p name="2849" id="2849" class="graf--p graf-after--pre">It’s enough to just say:</p><pre name="5342" id="5342" class="graf--pre graf-after--p">fetch(request);</pre><p name="dd71" id="dd71" class="graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Scope</strong></p><p name="2375" id="2375" class="graf--p graf-after--p">I set the scope parameter of my Service Worker to be “/”&nbsp;…but because the Service Worker is sitting in the root directory anyway, I don’t really need to do that. I could just register it with:</p><pre name="7732" id="7732" class="graf--pre graf-after--p">if (navigator.serviceWorker) {<br>  navigator.serviceWorker.register('/serviceworker.js');<br>}</pre><p name="ed3d" id="ed3d" class="graf--p graf-after--pre">If, on the other hand, the Service Worker file were sitting in a folder, but I wanted it to act on the whole site, <em class="markup--em markup--p-em">then</em> I would need to specify the scope:</p><pre name="bf00" id="bf00" class="graf--pre graf-after--p">if (navigator.serviceWorker) {<br>  navigator.serviceWorker.register('/path/to/serviceworker.js', {<br>    scope: '/'<br>  });<br>}</pre><p name="d8ed" id="d8ed" class="graf--p graf-after--pre">…and I’d also need to <a href="https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#service-worker-script-response" data-href="https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#service-worker-script-response" class="markup--anchor markup--p-anchor" rel="nofollow">send a special header</a>. So it’s probably easiest to just put Service Worker scripts in the root directory.</p><p name="d4f1" id="d4f1" class="graf--p graf-after--p graf--last"><em class="markup--em markup--p-em">This was originally posted </em><a href="https://adactio.com/journal/9775" data-href="https://adactio.com/journal/9775" class="markup--anchor markup--p-anchor" rel="canonical nofollow"><em class="markup--em markup--p-em">on my own site</em></a><em class="markup--em markup--p-em">.</em></p>
