---
title: "Why I Left Gulp and Grunt for npm Scripts — Medium"
description: "I know what you’re thinking. WAT?! Didn’t Gulp just kill Grunt? Why can’t we just be content for a few minutes here in J…"
link: "https://medium.com/@housecor/why-i-left-gulp-and-grunt-for-npm-scripts-3d6853dd22b8#.4irrc3nfk"
saved: "2016-01-27 14:38:02"
---
<section name="368f" class=" section--body section--first"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner layoutSingleColumn"><h3 name="b872" id="b872" class="graf--h3 graf--first">Why I Left Gulp and Grunt for npm Scripts</h3><figure name="8c87" id="8c87" class="graf--figure graf-after--h3"><div class="aspectRatioPlaceholder is-locked"><div class="progressiveMedia js-progressiveMedia graf-image is-canvasLoaded is-imageLoaded" data-image-id="1*DnSo0yGbkLsYscYR4sWOnA.png" data-width="693" data-height="693" data-scroll="native"><img src="https://cdn-images-2.medium.com/freeze/max/30/1*DnSo0yGbkLsYscYR4sWOnA.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail"><canvas class="progressiveMedia-canvas js-progressiveMedia-canvas" width="75" height="75"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-2.medium.com/max/800/1*DnSo0yGbkLsYscYR4sWOnA.png" src="https://cdn-images-2.medium.com/max/800/1*DnSo0yGbkLsYscYR4sWOnA.png"><noscript class="js-progressiveMedia-inner">&lt;img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-2.medium.com/max/800/1*DnSo0yGbkLsYscYR4sWOnA.png"&gt;</noscript></div></div></figure><p name="2509" id="2509" class="graf--p graf-after--figure">I know what you’re thinking. WAT?! Didn’t Gulp just kill Grunt? Why can’t we just be content for a few minutes here in JavaScript land? I hear ya, but…</p><blockquote name="31ce" id="31ce" class="graf--pullquote pullquote graf-after--p"><span class="markup--quote markup--pullquote-quote is-other" name="anon_1bbaa07cbc1f" data-creator-ids="anon">I’ve found Gulp and Grunt to be unnecessary abstractions. npm scripts are plenty powerful and often easier to live with.</span></blockquote><h4 name="dfe8" id="dfe8" class="graf--h4 graf-after--pullquote">Let’s Begin With An Example…</h4><p name="1a44" id="1a44" class="graf--p graf-after--h4">I was a big fan of Gulp. But on my last project, I ended up with 100’s of lines in my gulpfile and around a dozen Gulp plugins. I was struggling to integrate Webpack, Browsersync, hot reloading, Mocha and much more using Gulp. Why? Well, some plugins had insufficient documentation for my use case. Some plugins only exposed part of the API I needed. One had an odd bug where it would only watch a small number of files. Another stripped colors when outputting to the command line.</p><p name="276f" id="276f" class="graf--p graf-after--p">These are solvable problems, but <strong class="markup--strong markup--p-strong">none of these issues occurred when I called the tools directly.</strong></p><p name="c613" id="c613" class="graf--p graf-after--p">Lately I’ve noticed many open-source projects are simply using npm scripts. I decided to step back and re-examine. Did I really need Gulp? It turns out I didn’t.</p><p name="3e36" id="3e36" class="graf--p graf-after--p">I decided to try using just npm scripts on my new open source project. I created a rich dev environment and build process for React applications using just npm scripts. Curious what this looks like? Check out <a href="https://github.com/coryhouse/react-slingshot" data-href="https://github.com/coryhouse/react-slingshot" class="markup--anchor markup--p-anchor" rel="nofollow">React Slingshot</a>.</p><p name="3212" id="3212" class="graf--p graf-after--p">The surprising thing is, I now prefer working with npm scripts over Gulp. Here’s why.</p><h3 name="db1b" id="db1b" class="graf--h3 graf-after--p">What’s Wrong with Gulp and Grunt?</h3><p name="f7f5" id="f7f5" class="graf--p graf-after--h3">Over time, I’ve noticed three core issues with task runners like Gulp and Grunt:</p><ol class="postList"><li name="952b" id="952b" class="graf--li graf-after--p">Dependence on plugin authors</li><li name="b382" id="b382" class="graf--li graf-after--li">Frustrating debugging</li><li name="c7e6" id="c7e6" class="graf--li graf-after--li">Disjointed documentation</li></ol><p name="166b" id="166b" class="graf--p graf-after--li">Let’s consider each of these issues.</p><h4 name="e1da" id="e1da" class="graf--h4 graf-after--p">Issue #1: Dependence on Plugin Authors</h4><p name="f7a5" id="f7a5" class="graf--p graf-after--h4">When you’re working with new or unpopular technologies, no plugin may exist at all. And when a plugin exists, it may be outdated. For example, Babel 6 was recently released. The API changed significantly, so many Gulp plugins were incompatible with the latest version. When using Gulp, I was stuck because the Gulp plugin I needed wasn’t updated yet.</p><p name="df66" id="df66" class="graf--p graf-after--p">With Gulp or Grunt, you must wait for plugin maintainers to provide updates, or fix it yourself. This delays your ability to utilize new versions of modern tools. In contrast, <strong class="markup--strong markup--p-strong">when I use npm scripts, I consume tools directly without an extra layer of abstraction</strong>. This means when new versions of Mocha, Istanbul, Babel, Webpack, Browserify and so on are released, I’m able to utilize the new versions immediately.</p><p name="1cff" id="1cff" class="graf--p graf-after--p">In terms of selection, nothing beats npm:</p><figure name="4675" id="4675" class="graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked"><div class="progressiveMedia js-progressiveMedia graf-image is-canvasLoaded" data-image-id="1*Ukvg75zwIh7eZn35s8bs3g.png" data-width="474" data-height="253" data-scroll="native"><img src="https://cdn-images-2.medium.com/freeze/max/30/1*Ukvg75zwIh7eZn35s8bs3g.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail"><canvas class="progressiveMedia-canvas js-progressiveMedia-canvas" width="75" height="40"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-2.medium.com/max/800/1*Ukvg75zwIh7eZn35s8bs3g.png" src="https://cdn-images-2.medium.com/max/800/1*Ukvg75zwIh7eZn35s8bs3g.png"><noscript class="js-progressiveMedia-inner">&lt;img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-2.medium.com/max/800/1*Ukvg75zwIh7eZn35s8bs3g.png"&gt;</noscript></div></div><figcaption class="imageCaption">Gulp has ~2,100 plugins. Grunt has ~5,400. npm offers over 227,000 packages, growing at a rate of 400+ daily.</figcaption></figure><blockquote name="ca0b" id="ca0b" class="graf--pullquote pullquote graf-after--figure">When you use <strong class="markup--strong markup--pullquote-strong">npm scripts, you don’t search for a Grunt or Gulp plugin. You choose from over 227,000 npm packages.</strong></blockquote><p name="d087" id="d087" class="graf--p graf-after--pullquote">To be fair, if the Grunt or Gulp plugin you need isn’t available, you can certainly utilize npm packages directly. But then you’re no longer leveraging Gulp or Grunt for that specific task.</p><h4 name="ff85" id="ff85" class="graf--h4 graf-after--p">Issue #2: Frustrating Debugging</h4><p name="8c09" id="8c09" class="graf--p graf-after--h4">As integrations fail, debugging in Grunt and Gulp can be frustrating. Since you’re working with an extra layer of abstraction, there are more potential causes for any bug:</p><ol class="postList"><li name="1790" id="1790" class="graf--li graf-after--p">Is the base tool broken?</li><li name="7340" id="7340" class="graf--li graf-after--li">Is the Grunt/Gulp plugin broken?</li><li name="d135" id="d135" class="graf--li graf-after--li">Is my configuration broken?</li><li name="0231" id="0231" class="graf--li graf-after--li">Am I using incompatible versions?</li></ol><p name="5d8c" id="5d8c" class="graf--p graf-after--li">Using npm scripts eliminates #2. And I find #3 is far less common since I typically call the tool’s command line interface directly. Finally, #4 is less common since I’ve reduced the number of packages in my project by utilizing npm directly instead of using a task runner’s abstraction.</p><h4 name="1dcf" id="1dcf" class="graf--h4 graf-after--p">Issue #3: Disjointed Documentation</h4><p name="751e" id="751e" class="graf--p graf-after--h4">The documentation for the core tools I need is nearly always better than the associated Grunt and Gulp plugins. For example, if I use gulp-eslint, I end up splitting my time between the <a href="https://github.com/adametry/gulp-eslint" data-href="https://github.com/adametry/gulp-eslint" class="markup--anchor markup--p-anchor" rel="nofollow">gulp-eslint</a> docs and the ESLint website. I have to switch context between the plugin and the tool it is abstracting. The core piece of friction in Gulp and Grunt is this:</p><blockquote name="1316" id="1316" class="graf--pullquote pullquote graf-after--p"><strong class="markup--strong markup--pullquote-strong">Understanding the tool isn’t enough. Gulp and Grunt require you to understand the plugin’s abstraction.</strong></blockquote><p name="8453" id="8453" class="graf--p graf-after--pullquote">Most build-related tools offer clear, powerful, and well documented command line interfaces. See the <a href="http://eslint.org/docs/user-guide/command-line-interface" data-href="http://eslint.org/docs/user-guide/command-line-interface" class="markup--anchor markup--p-anchor" rel="nofollow">docs on ESLint’s CLI</a> as a good example. I find reading and implementing a short command line call in npm scripts clearer, lower friction, and easier to debug (since there’s a layer of abstraction removed).</p><p name="d44f" id="d44f" class="graf--p graf-after--p">Now that I’ve established the pain points, the question is, why do we think we need task runners like Gulp and Grunt?</p><h3 name="f97a" id="f97a" class="graf--h3 graf-after--p">Why Have We Ignored npm for builds?</h3><p name="2bd4" id="2bd4" class="graf--p graf-after--h3">I believe there are <strong class="markup--strong markup--p-strong">four core misconceptions</strong> that led to Gulp and Grunt becoming so popular:</p><ol class="postList"><li name="72aa" id="72aa" class="graf--li graf-after--p">People think npm scripts require strong command line skills</li><li name="98ff" id="98ff" class="graf--li graf-after--li">People think npm scripts aren’t powerful enough</li><li name="41c1" id="41c1" class="graf--li graf-after--li">People think Gulp’s streams are necessary for fast builds</li><li name="3598" id="3598" class="graf--li graf-after--li">People think npm scripts don’t run cross platform</li></ol><p name="37c5" id="37c5" class="graf--p graf-after--li">Let’s address these misconceptions in order.</p><h4 name="ceb1" id="ceb1" class="graf--h4 graf-after--p">Misconception #1<strong class="markup--strong markup--h4-strong">: </strong>npm Scripts Require Strong Command-Line Skills</h4><p name="356a" id="356a" class="graf--p graf-after--h4">You don’t have to know much about your operating system’s command line to enjoy the power of npm scripts. Sure, <a href="http://www.tutorialspoint.com/unix/unix-useful-commands.htm" data-href="http://www.tutorialspoint.com/unix/unix-useful-commands.htm" class="markup--anchor markup--p-anchor" rel="nofollow">grep, sed, awk, and pipes</a> are lifelong skills worth learning, but <strong class="markup--strong markup--p-strong">you don’t have to be a Unix or Windows command line wizard to use npm scripts</strong>. You can leverage the 1000’s of well documented scripts in npm to get the job done instead.</p><p name="4133" id="4133" class="graf--p graf-after--p">For instance, you might not know that in Unix this forcefully deletes a directory: rm -rf. That’s okay. You can use <a href="https://www.npmjs.com/package/rimraf" data-href="https://www.npmjs.com/package/rimraf" class="markup--anchor markup--p-anchor" rel="nofollow">rimraf</a> which does the same thing (and it works cross-platform to boot). Most npm packages offer interfaces that assume very little knowledge of your OS’s command line. Just search npm for packages that do what you need, read the docs, learn as you go. I used to search for Gulp plugins. Now I search for npm packages instead. A great resource: <a href="https://libraries.io/" data-href="https://libraries.io" class="markup--anchor markup--p-anchor" rel="nofollow">libraries.io</a>.</p><h4 name="3ceb" id="3ceb" class="graf--h4 graf-after--p"><strong class="markup--strong markup--h4-strong">Misconception #2: npm Scripts Aren’t Powerful Enough</strong></h4><p name="0ad2" id="0ad2" class="graf--p graf-after--h4">npm scripts are surprisingly powerful on their own. There are convention-based <a href="https://docs.npmjs.com/misc/scripts#description" data-href="https://docs.npmjs.com/misc/scripts#description" class="markup--anchor markup--p-anchor" rel="nofollow">pre and post hooks</a>:</p><figure name="47eb" id="47eb" class="graf--figure graf--iframe graf-after--p"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/cf13ea55c1041743ca49ddd6b46b668d?maxWidth=700" data-media-id="cf13ea55c1041743ca49ddd6b46b668d" frameborder="0"></iframe></div></figure><p name="9fcc" id="9fcc" class="graf--p graf-after--figure">All you do is follow convention. The scripts above will run in order based on their prefix. The prebuild script will run before the build script because it has the same name, but is prefixed with “pre”. The postbuild script will run after the build script because it has the prefix of “post”. So if I create scripts named prebuild, build, and postbuild, they’ll run automatically in that order when I type `npm run build`.</p><p name="44cd" id="44cd" class="graf--p graf-after--p">You can also decompose big problems by calling one script from another:</p><figure name="7115" id="7115" class="graf--figure graf--iframe graf-after--p"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/5b58ee0625720944a56197f07e46b02f?maxWidth=700" data-media-id="5b58ee0625720944a56197f07e46b02f" frameborder="0"></iframe></div></figure><p name="aca3" id="aca3" class="graf--p graf-after--figure">In this example the prebuild task calls the clean task. This allows you to decompose your scripts into small, well-named, single responsibility, one-liners.</p><p name="b438" id="b438" class="graf--p graf-after--p">You can call multiple scripts serially on a single line using &amp;&amp;. The scripts in the clean step above will run one after the other. This simplicity will really make you smile if you’re someone who has struggled with getting a list of tasks to run in order in Gulp.</p><p name="d013" id="d013" class="graf--p graf-after--p">And if a command gets too complicated, you can always call a separate file:</p><figure name="5463" id="5463" class="graf--figure graf--iframe graf-after--p"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/6dd561d5d8a3ae331219e8ec043443e5?maxWidth=700" data-media-id="6dd561d5d8a3ae331219e8ec043443e5" frameborder="0"></iframe></div></figure><p name="12fa" id="12fa" class="graf--p graf-after--figure">I’m calling a separate script in the build task above. That script will be run by Node and thus can utilize any npm packages I need, and utilize all the power of JavaScript inside.</p><p name="471f" id="471f" class="graf--p graf-after--p">I could go on, but <a href="https://docs.npmjs.com/misc/scripts" data-href="https://docs.npmjs.com/misc/scripts" class="markup--anchor markup--p-anchor" rel="nofollow">the core features are documented here</a>. Also, there’s also a short <a href="https://www.pluralsight.com/courses/npm-build-tool-introduction" data-href="https://www.pluralsight.com/courses/npm-build-tool-introduction" class="markup--anchor markup--p-anchor" rel="nofollow">Pluralsight course on using npm as a build tool</a>. Or, check out <a href="https://github.com/coryhouse/react-slingshot" data-href="https://github.com/coryhouse/react-slingshot" class="markup--anchor markup--p-anchor" rel="nofollow">React Slingshot</a> for an example of all this in action.</p><h4 name="c6fd" id="c6fd" class="graf--h4 graf-after--p">Misconception #3: Gulp’s Streams Are Necessary for Fast Builds</h4><p name="6672" id="6672" class="graf--p graf-after--h4">Gulp quickly gained traction over Grunt because Gulp’s in-memory streams are faster than Grunt’s file-based approach. But you don’t need Gulp to enjoy the power of streaming. In fact, <strong class="markup--strong markup--p-strong">streaming has always been built into both Unix and Windows command lines</strong>. The pipe (|) operator streams the output of one command to the input of another command. And the redirection (&gt;) operator redirects output to a file.</p><p name="9240" id="9240" class="graf--p graf-after--p">So, for example, in Unix I can use `grep` the contents of a file and redirect the output to a new file:</p><pre name="0a38" id="0a38" class="graf--pre graf-after--p">grep ‘Cory House’ bigFile.txt &gt; linesThatHaveMyName.txt</pre><p name="f2e3" id="f2e3" class="graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">The work above is streamed. No intermediate files are written. </strong>(Wondering how to do the command above in a cross-platform way? Read on…)</p><p name="d87c" id="d87c" class="graf--p graf-after--p">You can also use the `&amp;` operator to run two commands at the same time on Unix:</p><pre name="305e" id="305e" class="graf--pre graf-after--p">npm run script1.js &amp; npm run script2.js</pre><p name="8eaf" id="8eaf" class="graf--p graf-after--pre">The two scripts above will run in at the same time. To run scripts concurrently cross platform, use <a href="https://www.npmjs.com/package/npm-run-all" data-href="https://www.npmjs.com/package/npm-run-all" class="markup--anchor markup--p-anchor" rel="nofollow">npm-run-all</a>. This leads to the next misconception…</p><h4 name="a147" id="a147" class="graf--h4 graf-after--p">Misconception #4: npm Scripts Don’t Run Cross-platform</h4><p name="0d3a" id="0d3a" class="graf--p graf-after--h4">Many projects are tied to a specific operating system, so cross-platform concerns don’t matter. But if you need to run cross-platform, npm scripts can still work great. Countless open source projects are proof. Here’s how.</p><p name="0387" id="0387" class="graf--p graf-after--p">Your operating system’s command line runs your npm scripts. So on Linux and OSX, your npm scripts run on a Unix command line. On Windows, npm scripts run on the Windows command line. Thus, if you want your build scripts to run on all platforms, you need to make both Unix and Windows happy. Here are three approaches:</p><p name="7136" id="7136" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Approach 1:</strong> Use <a href="http://www.yolinux.com/TUTORIALS/unix_for_dos_users.html" data-href="http://www.yolinux.com/TUTORIALS/unix_for_dos_users.html" class="markup--anchor markup--p-anchor" rel="nofollow">commands that run cross-platform</a>. There’s a surprising number of cross-platform commands. Here’s a few:</p><pre name="78c3" id="78c3" class="graf--pre graf-after--p">&amp;&amp; chain tasks (Run one task after another)<br>&lt; input file contents to a command<br>&gt; redirect command output to a file<br>| redirect command output to another command</pre><p name="dd6a" id="dd6a" class="graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Approach 2:</strong> Use node packages. You can use node packages instead of shell commands. For instance, use <a href="https://www.npmjs.com/package/rimraf" data-href="https://www.npmjs.com/package/rimraf" class="markup--anchor markup--p-anchor" rel="nofollow">rimraf</a> instead of `rm -rf`. Use <a href="https://www.npmjs.com/package/cross-env" data-href="https://www.npmjs.com/package/cross-env" class="markup--anchor markup--p-anchor" rel="nofollow">cross-env</a> to set environment variables in a cross-platform way. Search Google, npm or <a href="https://libraries.io/" data-href="https://libraries.io" class="markup--anchor markup--p-anchor" rel="nofollow">libraries.io</a> for what you want to do and there is almost certainly a node package that will get it done cross-platform. And if your command line calls get too long, you can call Node packages in separate scripts as well like this:</p><pre name="bba7" id="bba7" class="graf--pre graf-after--p">node scriptName.js</pre><p name="ad1e" id="ad1e" class="graf--p graf-after--pre">The script above is plain old JavaScript, run by Node. And since you’re just calling a script on the command line, you’re not limited to&nbsp;.js files. You can run any script that your OS can execute such as Bash, Python, Ruby, or Powershell as well.</p><p name="16a7" id="16a7" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Approach 3</strong>: Use <a href="https://www.npmjs.com/package/shelljs" data-href="https://www.npmjs.com/package/shelljs" class="markup--anchor markup--p-anchor" rel="nofollow">ShellJS</a>. ShellJS is an npm package that runs Unix commands via Node. So this gives you the power to run Unix commands on all platforms, including Windows.</p><p name="008d" id="008d" class="graf--p graf-after--p">I used a combination of approach #1 and #2 on <a href="https://github.com/coryhouse/react-slingshot" data-href="https://github.com/coryhouse/react-slingshot" class="markup--anchor markup--p-anchor" rel="nofollow">React Slingshot</a>.</p><h3 name="b972" id="b972" class="graf--h3 graf-after--p">Pain Point</h3><p name="0c11" id="0c11" class="graf--p graf-after--h3">There are admittedly some downsides: The JSON spec doesn’t support comments, so you can’t add comments in package.json. There are a few ways to work around this limitation:</p><ol class="postList"><li name="5a81" id="5a81" class="graf--li graf-after--p">Write small, well-named, single purpose scripts</li><li name="1d5c" id="1d5c" class="graf--li graf-after--li">Document scripts separately (in a README.md for instance)</li><li name="223b" id="223b" class="graf--li graf-after--li">Call a separate&nbsp;.js file</li></ol><p name="e960" id="e960" class="graf--p graf-after--li">I prefer option #1. If you break each script down to have a single responsibility, comments are rarely necessary. <strong class="markup--strong markup--p-strong">The script’s name should fully describe the intent, just like any small well-named function.</strong> As I discuss in “<a href="https://www.pluralsight.com/courses/writing-clean-code-humans" data-href="https://www.pluralsight.com/courses/writing-clean-code-humans" class="markup--anchor markup--p-anchor" rel="nofollow">Clean Code: Writing Code for Humans</a>”, small single responsibility functions rarely require comments. When I feel a comment is necessary, I use option #3 and move the script to a separate file. This gives me all the compositional power of JavaScript when I need it.</p><p name="bffb" id="bffb" class="graf--p graf-after--p">Package.json also doesn’t support variables. This sounds like a big deal, but it’s not for two reasons. First, the most common need for variables revolves around environment, which you can set on the command line. Second, if you need variables for other reasons, you can call a separate&nbsp;.js file. Check out <a href="https://github.com/kriasoft/react-starter-kit/blob/master/package.json#L74" data-href="https://github.com/kriasoft/react-starter-kit/blob/master/package.json#L74" class="markup--anchor markup--p-anchor" rel="nofollow">React-starter-kit</a> for an elegant example of this pattern.</p><p name="7df5" id="7df5" class="graf--p graf-after--p">Finally, there’s also a risk of creating long, complex command line arguments that are difficult to understand. Code reviews and diligent refactoring are a great way to assure npm scripts are decomposed into small, well-named, single purpose functions that everyone understands. If it’s complex enough to need a comment, you should likely refactor the single script into multiple well named scripts or extract it to a separate file.</p><h4 name="8a22" id="8a22" class="graf--h4 graf-after--p">Abstractions Must Be Justified</h4><p name="fd8c" id="fd8c" class="graf--p graf-after--h4">Gulp and Grunt are abstractions over the tools I use. Abstractions are useful, but abstractions have a cost. They leak. They make us dependent upon the plugin maintainers and their documentation. And they add complexity by increasing the number of dependencies. I’ve decided task runners like Gulp and Grunt are abstractions I no longer need.</p><p name="ffe7" id="ffe7" class="graf--p graf-after--p">Comments? Chime in below or on <a href="https://www.reddit.com/r/javascript/comments/41e1ys/why_i_left_gulp_and_grunt_for_npm_scripts/" data-href="https://www.reddit.com/r/javascript/comments/41e1ys/why_i_left_gulp_and_grunt_for_npm_scripts/" class="markup--anchor markup--p-anchor" rel="nofollow">Reddit</a> or <a href="https://news.ycombinator.com/item?id=10929476" data-href="https://news.ycombinator.com/item?id=10929476" class="markup--anchor markup--p-anchor" rel="nofollow">Hacker News</a>.</p><p name="a0b8" id="a0b8" class="graf--p graf-after--p">I’m far from the first person to suggest this. Here are some excellent links:</p><ul class="postList"><li name="6fd1" id="6fd1" class="graf--li graf-after--p"><a href="http://substack.net/task_automation_with_npm_run" data-href="http://substack.net/task_automation_with_npm_run" class="markup--anchor markup--li-anchor" rel="nofollow">Task automation with npm run</a> — James Holliday</li><li name="2fb0" id="2fb0" class="graf--li graf-after--li"><a href="https://www.youtube.com/watch?v=0RYETb9YVrk" data-href="https://www.youtube.com/watch?v=0RYETb9YVrk" class="markup--anchor markup--li-anchor" rel="nofollow">Advanced front-end automation with npm scripts</a> — Kate Hudson</li><li name="80d6" id="80d6" class="graf--li graf-after--li"><a href="http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/" data-href="http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/" class="markup--anchor markup--li-anchor" rel="nofollow">How to use npm as a build tool</a> — Kieth Cirkel</li><li name="23b3" id="23b3" class="graf--li graf-after--li"><a href="http://app.pluralsight.com/courses/npm-build-tool-introduction" data-href="http://app.pluralsight.com/courses/npm-build-tool-introduction" class="markup--anchor markup--li-anchor" rel="nofollow">Introduction to npm as a Build Tool</a> — Marcus Hammarberg</li><li name="89b8" id="89b8" class="graf--li graf-after--li"><a href="http://gon.to/2015/02/26/gulp-is-awesome-but-do-we-really-need-it/" data-href="http://gon.to/2015/02/26/gulp-is-awesome-but-do-we-really-need-it/" class="markup--anchor markup--li-anchor" rel="nofollow">Gulp is awesome, but do we really need it?</a> — Gonto</li><li name="5b54" id="5b54" class="graf--li graf-after--li graf--last"><a href="http://code.tutsplus.com/courses/npm-scripts-for-build-tooling" data-href="http://code.tutsplus.com/courses/npm-scripts-for-build-tooling" class="markup--anchor markup--li-anchor" rel="nofollow">NPM Scripts for Build Tooling</a> — Andrew Burgess</li></ul></div></div></section><section name="bae6" class=" section--body section--last"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner layoutSingleColumn"><p name="fa2c" id="fa2c" class="graf--p graf--first graf--last"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Cory House</em></strong> is the author of “<a href="https://www.pluralsight.com/courses/react-flux-building-applications" data-href="https://www.pluralsight.com/courses/react-flux-building-applications" class="markup--anchor markup--p-anchor" rel="nofollow">Building Applications with React and Flux</a>”, “<a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwiK1pXx89nJAhUujoMKHeuWAEUQFggcMAA&amp;url=https%3A%2F%2Fwww.pluralsight.com%2Fcourses%2Fwriting-clean-code-humans&amp;usg=AFQjCNEBfkBoN-IgCn_1jFUqWDAUIxcmAw&amp;sig2=Ub9Wup4k4mrw_ffPgYu3tA" data-href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwiK1pXx89nJAhUujoMKHeuWAEUQFggcMAA&amp;url=https%3A%2F%2Fwww.pluralsight.com%2Fcourses%2Fwriting-clean-code-humans&amp;usg=AFQjCNEBfkBoN-IgCn_1jFUqWDAUIxcmAw&amp;sig2=Ub9Wup4k4mrw_ffPgYu3tA" class="markup--anchor markup--p-anchor" rel="nofollow">Clean Code: Writing Code for Humans</a>” and multiple other courses on Pluralsight. He is a Software Architect at VinSolutions and <a href="http://www.bitnative.com/training/" data-href="http://www.bitnative.com/training/" class="markup--anchor markup--p-anchor" rel="nofollow">trains software developers internationally</a> on software practices like front-end development and clean coding. Cory is a Microsoft MVP, Telerik Developer Expert, and founder of <a href="http://www.outlierdeveloper.com/" data-href="http://www.outlierdeveloper.com" class="markup--anchor markup--p-anchor" rel="nofollow">outlierdeveloper.com</a>.</p></div></div></section>