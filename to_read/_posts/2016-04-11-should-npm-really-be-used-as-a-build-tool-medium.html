---
title: "Should npm Really Be Used as a Build Tool? — Medium"
description: "I’d like to talk about one of the web’s new “best practises” and my personal experiences with it. The intention behind t…"
link: "https://medium.com/@leo/should-npm-really-be-used-as-a-built-tool-e8ff4f6cbcef#.8hyn6hrco"
saved: "2016-04-11 17:49:43"
---
<section name="7509" class=" section--body section--first section--last"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner layoutSingleColumn"><h3 name="f82c" id="f82c" class="graf--h3 graf--first">Should npm Really Be Used as a Build Tool?</h3><p name="df3f" id="df3f" class="graf--p graf-after--h3">I’d like to talk about one of the web’s new “best practises” and my personal experiences with it. The intention behind this article isn’t to get as much developers as possible away from using npm as a build tool, but rather to contribute to a large, global thought process about whether or not it should be considered a “best practise”.</p><p name="8ca9" id="8ca9" class="graf--p graf-after--p">I’m saying this because I definitely think that I’ve got a pretty good view on this whole topic. However, there still might be some areas in which solutions for problems exist, but I simply haven’t found out about them yet.</p><p name="a8e5" id="a8e5" class="graf--p graf-after--p">So please don’t use this as an excuse for staying with Gulp, Grunt or Broccoli, but rather just add it to the information you’ve gathered from other places around the web and then make a decision!</p><h4 name="2175" id="2175" class="graf--h4 graf-after--p">Why npm?</h4><p name="d7a6" id="d7a6" class="graf--p graf-after--h4">Let’s start with the intention behind using npm as a build tool and why many of us came to the conclusion that it might be a better choice than using existing packages:</p><p name="1ba2" id="1ba2" class="graf--p graf-after--p">First of all, I think we both agree on the fact that good developers are always on the path of trying to find the simplest, easiest and fastest way to get a certain task done. And this exactly where things like Gulp and Grunt started to become a thorn in our sides:</p><p name="d235" id="d235" class="graf--p graf-after--p">While our builds became more and more complex (transpiling next-level JavaScript, compiling different syntax languages like SCSS or Coffeescript into their main language, preparing/transpiling tests and moving static files), our configuration files also started becoming much bigger and complex as well.</p><p name="a5fd" id="a5fd" class="graf--p graf-after--p">And then, suddenly, many of us found themselves writing multiple hundreds of lines of code just for the process of preparing all files for being delivered to the user/customer (here’s a really <a href="https://github.com/TryGhost/Ghost/blob/master/Gruntfile.js" data-href="https://github.com/TryGhost/Ghost/blob/master/Gruntfile.js" class="markup--anchor markup--p-anchor" rel="nofollow">extreme example</a>, which also isn’t just related to build tools, but rather to task managers at all).</p><p name="dc28" id="dc28" class="graf--p graf-after--p">So it didn’t take much time until some developers started looking for a simpler and cleaner way to handle all of this. And since our projects already had a “package.json” file inside them (which is necessary for defining a build tool’s dependencies), <a href="https://docs.npmjs.com/misc/scripts" data-href="https://docs.npmjs.com/misc/scripts" class="markup--anchor markup--p-anchor" rel="nofollow">npm-scripts</a> were one of the first things that seemed like a proper alternative.</p><h4 name="83ab" id="83ab" class="graf--h4 graf-after--p">The Remorse</h4><p name="8753" id="8753" class="graf--p graf-after--h4">Sadly, the joy didn’t last long. After people like me started converting their excitement of knowing how to simplify a certain task into a practical solution, it already started to get shitty again:</p><figure name="8fc7" id="8fc7" class="graf--figure graf--iframe graf-after--p"><div class="iframeContainer"><iframe data-width="435" data-height="176" width="435" height="176" src="https://medium.com/media/2a799e814d9ae9890faf4769b377cbfa?maxWidth=435" data-media-id="2a799e814d9ae9890faf4769b377cbfa" frameborder="0"></iframe></div></figure><p name="28a5" id="28a5" class="graf--p graf-after--figure">At first, I just had a single property in package.scripts and it was called “build”. And what it did was transpile my ES2015 code using Babel into ES5 code. “So far so good!”, I thought.</p><p name="b5d8" id="b5d8" class="graf--p graf-after--p">But then, as soon as I started digging into the other stuff I had to take care of (like compiling SCSS, starting a livereload server, bundling my ES2015 modules or implementing a file watcher), it started getting messy:</p><figure name="5914" id="5914" class="graf--figure graf--iframe graf-after--p"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/5cdd376bf9b219e8d05b0a6be74a7607?maxWidth=700" data-media-id="5cdd376bf9b219e8d05b0a6be74a7607" frameborder="0"></iframe></div></figure><p name="475b" id="475b" class="graf--p graf-after--figure">That’s how it looked before I switched back to Gulp. And remember, the upper example doesn’t even include tests. If you want to see how that looks, here’s <a href="https://github.com/testdouble/testdouble.js/blob/d3776200f6f6cc29ae93e3bf94fcfafa94e3380a/package.json#L16" data-href="https://github.com/testdouble/testdouble.js/blob/d3776200f6f6cc29ae93e3bf94fcfafa94e3380a/package.json#L16" class="markup--anchor markup--p-anchor" rel="nofollow">another one</a>.</p><ul class="postList"><li name="9c64" id="9c64" class="graf--li graf-after--p">A lot of things are being defined multiple times (like paths and subcommands), which makes maintenance very hard.</li><li name="2776" id="2776" class="graf--li graf-after--li">You’re required to ensure that the destination directory and all sub directories exist before running an actual build task (I’ve did that using “prebuild”). If you don’t do that, many compilers/transpilers will throw an error telling you that the destination path doesn’t exist.</li><li name="b32c" id="b32c" class="graf--li graf-after--li">I haven’t found a way to use a single watching process and pass the changed files over to the respective build task instead of using a CLI tool like <a href="https://github.com/keithamus/parallelshell" data-href="https://github.com/keithamus/parallelshell" class="markup--anchor markup--li-anchor" rel="nofollow">parallelshell</a> to run multiple of those watchers in parallel.</li><li name="9c5f" id="9c5f" class="graf--li graf-after--li">These watchers also won’t care if only a single SCSS file (for example) has been changed. Instead of that, they will simply trigger a rebuild of all stylesheets because nobody tells them which ones have changed!</li><li name="1ebc" id="1ebc" class="graf--li graf-after--li">Tools like Gulp and Broccoli already include a well thought-out caching mechanism which reduces the build time to a few milliseconds (using in-memory file caches like <a href="https://www.npmjs.com/package/gulp-cached" data-href="https://www.npmjs.com/package/gulp-cached" class="markup--anchor markup--li-anchor" rel="nofollow">gulp-cached</a> even allows you to reach a overall build time of just nanoseconds). When using things like node-sass or babel directly, you’ll get a much slower speed.</li></ul><p name="a458" id="a458" class="graf--p graf-after--li">Not very compelling, right? That’s what I thought. So I’ve decided to switch back and go with <a href="http://ember-cli.com/" data-href="http://ember-cli.com" class="markup--anchor markup--p-anchor" rel="nofollow">ember-cli</a> for my latest web application (at the core, it basically uses <a href="http://broccolijs.com/" data-href="http://broccolijs.com" class="markup--anchor markup--p-anchor" rel="nofollow">Broccoli</a> to compile the code).</p><p name="a9c1" id="a9c1" class="graf--p graf-after--p">But the same applies to Gulp and Grunt: Everything is cached, I don’t need to define things like paths multiple times and all of the basic logic is done by the tool itself (like ensuring that all destination paths exist).</p><h4 name="05bc" id="05bc" class="graf--h4 graf-after--p">Possible fixes</h4><p name="119b" id="119b" class="graf--p graf-after--h4">Technically, just running watchers concurrently and rebuilding if necessary isn’t enough for a real web application. At the same time, we also have to make sure that we’re serving the static files and the API/server code. And all of this stuff should preferably happen in a single process (to avoid monitoring multiple terminal windows, for example).</p><p name="0315" id="0315" class="graf--p graf-after--p">To address the above problems, awesome people like Justin Searls started creating ways to outsource all of that shell scripting within “package.json” into separated, clean and carefully structured files.</p><p name="e2bd" id="e2bd" class="graf--p graf-after--p">A great example for this intention is <a href="https://github.com/testdouble/scripty" data-href="https://github.com/testdouble/scripty" class="markup--anchor markup--p-anchor" rel="nofollow">scripty</a> — a tool which allows you to put all of your task configurations into executables located in a single folder called “scripts” in your module’s root directory.</p><p name="fe6b" id="fe6b" class="graf--p graf--startsWithDoubleQuote graf-after--p">“Isn’t that great, we’ve just found a way to solve all of our problems!”, you might think now. But I’d like to ask you the following: Are you sure that we’ve really made progress on this topic by choosing npm instead of Gulp or Grunt as a built tool?</p><p name="14b7" id="14b7" class="graf--p graf-after--p">Because if you ask me, we clearly haven’t. Instead of that, we’re basically trying to <a href="https://en.wikipedia.org/wiki/Reinventing_the_wheel" data-href="https://en.wikipedia.org/wiki/Reinventing_the_wheel" class="markup--anchor markup--p-anchor" rel="nofollow">reinvent</a> a already fine working solution by fixing problems which we didn’t even have before.</p><figure name="1763" id="1763" class="graf--figure graf--iframe graf-after--p"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/8d8b2a2d85b00176edfd9289ef42c054?maxWidth=700" data-media-id="8d8b2a2d85b00176edfd9289ef42c054" frameborder="0"></iframe></div></figure><p name="1f28" id="1f28" class="graf--p graf-after--figure">What’s the next logical step after moving your tasks into separate files? Exactly: You’re going to find a way to share code between multiple tasks, implement some logic and finally create a package called “Gulp” which enforces a clean task configuration structure.</p><h4 name="987c" id="987c" class="graf--h4 graf-after--p">A compromise</h4><p name="b525" id="b525" class="graf--p graf-after--h4">You know what? I’m fine with looking at npm as a <strong class="markup--strong markup--p-strong">task manager</strong>. But what I definitely can’t recommend is using it as a <strong class="markup--strong markup--p-strong">build tool</strong>.</p><p name="d128" id="d128" class="graf--p graf-after--p">Those things might sound similar, but they’re still fundamentally different: While a task manager controls all of the tasks necessary to develop a web application, a build tool only covers the part of preparing your code for being delivered to the end user.</p><p name="6570" id="6570" class="graf--p graf-after--p">So all in all, my personal suggestion is to stay away from too much shell scripting related to package.scripts and rather start “build”-ing your code using <a href="http://gulpjs.com/" data-href="http://gulpjs.com" class="markup--anchor markup--p-anchor" rel="nofollow">Gulp</a> or <a href="http://broccolijs.com/" data-href="http://broccolijs.com" class="markup--anchor markup--p-anchor" rel="nofollow">Broccoli</a>. But at the same time, feel free to control those build tools through the “script” property within “package.json”.</p><p name="b585" id="b585" class="graf--p graf-after--p">However, I’m not trying to suggest the use of a certain build tool. Just go with what suits you and your team the best!</p><p name="3447" id="3447" class="graf--p graf-after--p">While doing so, make sure to take a look at the configuration files of other awesome projects to understand what they’re doing to keep them <a href="https://github.com/muffinjs/app/blob/dd273d1a3808cb3cb9dea9862faa1b7f25522f46/gulpfile.js" data-href="https://github.com/muffinjs/app/blob/dd273d1a3808cb3cb9dea9862faa1b7f25522f46/gulpfile.js" class="markup--anchor markup--p-anchor" rel="nofollow">as simple as possible</a> and apply it to your own code!</p><p name="b9bd" id="b9bd" class="graf--p graf-after--p graf--last">And now a huge “Thank you!” for taking the time to read this! If you like my work, please consider hitting that little green heart at the bottom. Really helps me out a lot!</p></div></div></section>