---
title: "Functional Programming for JavaScript People — Medium"
description: "Like many of you, I started hearing a lot about functional programming several months ago and I had no idea what it was.…"
link: "https://medium.com/@chetcorcos/functional-programming-for-javascript-people-1915d8775504#.2723qhtlg"
saved: "2016-03-21 15:03:22"
---
<section name="f84d" class=" section--body section--first section--last"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner u-sizeFullWidth"><figure name="b0c4" id="b0c4" class="graf--figure graf--layoutFillWidth graf--first"><div class="aspectRatioPlaceholder is-locked"><div class="aspectRatioPlaceholder-fill"></div><div class="progressiveMedia js-progressiveMedia graf-image is-canvasLoaded is-imageLoaded" data-image-id="1*KPy3bUBCUFy6zqNFZys9lQ.png" data-width="2010" data-height="946" data-scroll="native"><img src="https://cdn-images-2.medium.com/freeze/max/30/1*KPy3bUBCUFy6zqNFZys9lQ.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail"><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-2.medium.com/max/2000/1*KPy3bUBCUFy6zqNFZys9lQ.png" src="https://cdn-images-2.medium.com/max/2000/1*KPy3bUBCUFy6zqNFZys9lQ.png"><noscript class="js-progressiveMedia-inner">&lt;img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-2.medium.com/max/2000/1*KPy3bUBCUFy6zqNFZys9lQ.png"&gt;</noscript></div></div></figure></div><div class="section-inner layoutSingleColumn"><h3 name="d5c8" id="d5c8" class="graf--h3 graf-after--figure">Functional Programming for JavaScript People</h3><p name="dc71" id="dc71" class="graf--p graf-after--h3">Like many of you, I started hearing a lot about functional programming several months ago and I had no idea what it was. It was just a buzzword to me. Since then, I’ve explored the depths of functional programming and I thought I’d try to help demystify the newcomer who keeps hearing about all this stuff but doesn’t know what to make of it.</p><p name="3443" id="3443" class="graf--p graf-after--p">When talking about functional programming languages, there tends to be a few flavors: <a href="https://www.haskell.org/" data-href="https://www.haskell.org" class="markup--anchor markup--p-anchor" rel="nofollow">Haskell</a> and <a href="https://en.wikipedia.org/wiki/Lisp_%28programming_language%29" data-href="https://en.wikipedia.org/wiki/Lisp_%28programming_language%29" class="markup--anchor markup--p-anchor" rel="nofollow">Lisp</a>, with <a href="https://news.ycombinator.com/item?id=4122764" data-href="https://news.ycombinator.com/item?id=4122764" class="markup--anchor markup--p-anchor" rel="nofollow">plenty</a> of <a href="https://www.reddit.com/r/haskell/comments/2mr7ks/im_debating_between_haskell_and_clojure_xpost/" data-href="https://www.reddit.com/r/haskell/comments/2mr7ks/im_debating_between_haskell_and_clojure_xpost/" class="markup--anchor markup--p-anchor" rel="nofollow">debate</a> over <a href="https://www.quora.com/Which-power-programming-language-should-I-put-the-effort-into-learning-this-year-Clojure-or-Haskell" data-href="https://www.quora.com/Which-power-programming-language-should-I-put-the-effort-into-learning-this-year-Clojure-or-Haskell" class="markup--anchor markup--p-anchor" rel="nofollow">which is better</a>. Although they are both functional languages, they are in fact quite different, each with their own trade-offs. By the end of this article, I hope you have a better idea of what those are. Both have their share of descendant languages as well. Two such languages that you may have heard of are <a href="http://elm-lang.org/" data-href="http://elm-lang.org" class="markup--anchor markup--p-anchor" rel="nofollow">Elm</a> and <a href="https://github.com/clojure/clojurescript" data-href="https://github.com/clojure/clojurescript" class="markup--anchor markup--p-anchor" rel="nofollow">Clojurescript</a>, both of which compile into JavaScript. But before I get into the specifics of each language, <strong class="markup--strong markup--p-strong">my real goal is to instill in you some of the core concepts and patterns behind functional programming</strong>.</p><blockquote name="b4db" id="b4db" class="graf--blockquote graf-after--p">I highly recommend having at least one cup of coffee on hand before diving into this rabbit hole.</blockquote><h4 name="6ee0" id="6ee0" class="graf--h4 graf-after--blockquote">Pure Functions</h4><p name="bf92" id="bf92" class="graf--p graf-after--h4">At the heart of functional programming is the formal mathematics of describing logic: <a href="https://en.wikipedia.org/wiki/Lambda_calculus" data-href="https://en.wikipedia.org/wiki/Lambda_calculus" class="markup--anchor markup--p-anchor" rel="nofollow">lambda calculus</a>. Mathematicians like to describe programs as transformations of data which leads to the first concept — <a href="https://en.wikipedia.org/wiki/Pure_function" data-href="https://en.wikipedia.org/wiki/Pure_function" class="markup--anchor markup--p-anchor" rel="nofollow">pure functions</a>. Pure functions are functions without <a href="https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29" data-href="https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29" class="markup--anchor markup--p-anchor" rel="nofollow">side-effects</a>. <strong class="markup--strong markup--p-strong">Pure functions depend only on the inputs of the function, and the output should be the exact same for the same input.</strong> Here’s an example:</p><pre name="1c7e" id="1c7e" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">// pure function</strong><br>const add10 = (a) =&gt; a + 10</pre><pre name="dfbe" id="dfbe" class="graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">// impure function due to external non-constants<br></strong>let x = 10<br>const addx = (a) =&gt; a + x</pre><pre name="6f5c" id="6f5c" class="graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">// also impure due to side-effect<br></strong>const setx = (v) =&gt; x = v </pre><p name="e826" id="e826" class="graf--p graf-after--pre">The impure function indirectly depends on <em class="markup--em markup--p-em">x</em>. If you were to change <em class="markup--em markup--p-em">x</em>, then <em class="markup--em markup--p-em">addx</em> would output a different value for the same inputs. This makes it hard to statically analyze and optimize programs at compile-time. But more pragmatically for JavaScript developers, <strong class="markup--strong markup--p-strong">pure functions bound the congnitive load of programming</strong>. When you’re writing a pure function, you only need to concern yourself with the body of the function. You don’t need to worry about externalities that could cause problems, like anything that could change <em class="markup--em markup--p-em">x</em> while when you’re writing the <em class="markup--em markup--p-em">addx</em> function.</p><h4 name="56d7" id="56d7" class="graf--h4 graf-after--p">Function Composition</h4><p name="06e3" id="06e3" class="graf--p graf-after--h4">One nice thing about pure functions is that you can <em class="markup--em markup--p-em">compose</em> them into new functions. One special operator used to describe programs in lambda calculus is <a href="https://en.wikipedia.org/wiki/Function_composition" data-href="https://en.wikipedia.org/wiki/Function_composition" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">compose</em></a>. Compose takes two functions and “composes” them into a new function. Check it out:</p><pre name="bc96" id="bc96" class="graf--pre graf-after--p">const add1 = (a) =&gt; a + 1<br>const times2 = (a) =&gt; a * 2<br>const compose = (a, b) =&gt; (c) =&gt; a(b(c))<br>const add1OfTimes2 = compose(add1, times2)<br>add1OfTimes2(5) // =&gt; 11</pre><p name="8ef0" id="8ef0" class="graf--p graf-after--pre">The <em class="markup--em markup--p-em">compose</em> is analogous to the preposition “of”. Notice the order of the arguments and how they’re evaluated: add one <em class="markup--em markup--p-em">of</em> times two — the second function is evaluated first. Compose is the opposite of perhaps a more intuitive function you might be familiar with from unix called <em class="markup--em markup--p-em">pipe</em>, which accepts an array of functions.</p><pre name="19d8" id="19d8" class="graf--pre graf-after--p">const pipe = (fns) =&gt; (x) =&gt; fns.reduce((v, f) =&gt; f(v), x)<br>const times2add1 = pipe([time2, add1])<br>times2add1(5) // =&gt; 11</pre><p name="0354" id="0354" class="graf--p graf-after--pre">With function composition, we can now build more complicated data transformations by joining together (composing) smaller functions. <a href="http://fr.umio.us/why-ramda/" data-href="http://fr.umio.us/why-ramda/" class="markup--anchor markup--p-anchor" rel="nofollow">This article</a> does a great job of showing you how function composition can help you process data in a clean an concise way.</p><p name="e0aa" id="e0aa" class="graf--p graf-after--p">Pragmatically speaking, <strong class="markup--strong markup--p-strong">composition is a <em class="markup--em markup--p-em">better</em> alternative to object oriented inheretance</strong>. Here’s a contrived, but real-world example for you. Suppose you need to create a greeting for your users.</p><pre name="9115" id="9115" class="graf--pre graf-after--p">const greeting = (name) =&gt; `Hello ${name}`</pre><p name="5601" id="5601" class="graf--p graf-after--pre">Great! A simple, pure function. Then, your project manager says you now have some more data about your users and wants you to add prefixes to the names. So you go ahead and write this code:</p><pre name="bb48" id="bb48" class="graf--pre graf-after--p">const greeting = (name, male=false, female=false) =&gt;<br>  `Hello ${male ? ‘Mr. ‘ : female ? ‘Ms. ‘ : ‘’} ${name}`</pre><p name="e716" id="e716" class="graf--p graf-after--pre">This code isn’t terrible, but what if we start adding more and more booleans for other categories such as “Dr.” or “Sir”? What if we add suffixes as well such as “MD” or “PhD”? And what if we want to have a casual greeting that says “Sup” instead of “Hello”? Well now things have really gotten out of hand.</p><p name="a3d4" id="a3d4" class="graf--p graf-after--p">Adding booleans like this to a function isn’t exactly object oriented inheritance, but its a similar situation to when objects have properties and methods that get extended and overridden as they inherit. So as opposed to adding boolean options, lets try to use function composition:</p><pre name="e452" id="e452" class="graf--pre graf-after--p">const formalGreeting = (name) =&gt; `Hello ${name}`<br>const casualGreeting = (name) =&gt; `Sup ${name}`<br>const male = (name) =&gt; `Mr. ${name}`<br>const female = (name) =&gt; `Mrs. ${name}`<br>const doctor = (name) =&gt; `Dr. ${name}`<br>const phd = (name) =&gt; `${name} PhD`<br>const md = (name) =&gt; `${name} M.D.`</pre><pre name="5d97" id="5d97" class="graf--pre graf-after--pre">formalGreeting(male(phd("Chet"))) // =&gt; "Hello Mr. Chet PhD"</pre><p name="6069" id="6069" class="graf--p graf-after--pre">This is much more manageable and easier to reason about. Each function does a <a href="https://en.wikipedia.org/wiki/Unix_philosophy" data-href="https://en.wikipedia.org/wiki/Unix_philosophy" class="markup--anchor markup--p-anchor" rel="nofollow">one simple thin</a>g and we’re able to compose them together easily. Now, we haven’t handled all the cases here, and for that we can use our handy pipe function!</p><pre name="0fbf" id="0fbf" class="graf--pre graf-after--p">const identity = (x) =&gt; x<br>const greet = (name, options) =&gt; {<br>  return pipe([<br>    <strong class="markup--strong markup--pre-strong">// greeting</strong>    <br>    options.formal ? formalGreeting :<br>    casualGreeting,<br>    <strong class="markup--strong markup--pre-strong">// prefix</strong><br>    options.doctor ? doctor :<br>    options.male ? male :<br>    options.female ? female :<br>    identity,<br>    <strong class="markup--strong markup--pre-strong">// suffix</strong><br>    options.phd ? phd :<br>    options.md ?md :<br>    identity<br>  ])(name)<br>}</pre><p name="a211" id="a211" class="graf--p graf-after--pre">Another benefit of using pure functions and function composition is its much easier to trace errors. <span class="markup--quote markup--p-quote is-other" name="anon_e4c379b712a7" data-creator-ids="anon">Whenever you get an error, you should be able to see a stack trace through every function down to the source of the bug. In object oriented programming, its often quite confusing because you don’t always know the state of the rest of the object which led to the bug.</span></p><h4 name="e17e" id="e17e" class="graf--h4 graf-after--p">Function Currying</h4><p name="c2af" id="c2af" class="graf--p graf-after--h4">Function currying was invented by the same guy who invented Haskell — his name: <a href="https://en.wikipedia.org/wiki/Haskell_Curry" data-href="https://en.wikipedia.org/wiki/Haskell_Curry" class="markup--anchor markup--p-anchor" rel="nofollow">Haskell Curry</a> (correction: named after Haskell Curry). Function currying is when you call a function with fewer arguments than it wants and that function returns another function to accept the rest of the arguments. <a href="https://hughfdjackson.com/javascript/why-curry-helps/" data-href="https://hughfdjackson.com/javascript/why-curry-helps/" class="markup--anchor markup--p-anchor" rel="nofollow">This is a good article that explains</a> it in more detail, but here’s a simple example using the <a href="http://ramdajs.com/0.19.1/docs/#curry" data-href="http://ramdajs.com/0.19.1/docs/#curry" class="markup--anchor markup--p-anchor" rel="nofollow">Ramda.js curry function</a>.</p><p name="8f4b" id="8f4b" class="graf--p graf-after--p">In the example below, we create a curried function “add”, which takes in two arguments. When we pass one argument, we get back a partially applied function we call “add1” which only takes one argument.</p><pre name="3f56" id="3f56" class="graf--pre graf-after--p">const add = R.curry((a, b) =&gt; a + b)<br>add(1, 2) // =&gt; 3<br>const add1 = add(1)<br>add1(2) // =&gt; 3<br>add1(10) // =&gt; 11</pre><p name="521c" id="521c" class="graf--p graf-after--pre">In Haskell, all functions are automatically curried. There are no optional or default arguments.</p><p name="8803" id="8803" class="graf--p graf-after--p">Pragmatically, function currying is really convenient when using functions with <em class="markup--em markup--p-em">map</em>, <em class="markup--em markup--p-em">compose</em> and <em class="markup--em markup--p-em">pipe. </em>For example:</p><pre name="d6de" id="d6de" class="graf--pre graf-after--p">const users = [{name: 'chet', age:25}, {name:'joe', age:24}]<br>R.pipe(<br>  R.sortBy(R.prop('age')), <strong class="markup--strong markup--pre-strong">// sort user by the age property</strong><br>  R.map(R.prop('name')),   <strong class="markup--strong markup--pre-strong">// get each name property</strong><br>  R.join(', '),            <strong class="markup--strong markup--pre-strong">// join the names with a comma</strong><br>)(users)<br><strong class="markup--strong markup--pre-strong">// =&gt; "joe, chet"</strong></pre><p name="7d52" id="7d52" class="graf--p graf-after--pre">This makes data processing feel very declarative. Notice how the code reads just like the comments!</p><h4 name="0953" id="0953" class="graf--h4 graf-after--p">Monads, Functors, and Fancy Words</h4><p name="296c" id="296c" class="graf--p graf-after--h4"><a href="https://en.wikipedia.org/wiki/Monad_%28functional_programming%29" data-href="https://en.wikipedia.org/wiki/Monad_%28functional_programming%29" class="markup--anchor markup--p-anchor" rel="nofollow">Monads</a> and <a href="https://en.wikipedia.org/wiki/Functor" data-href="https://en.wikipedia.org/wiki/Functor" class="markup--anchor markup--p-anchor" rel="nofollow">functors</a> are just fancy words for things you already know. If you want to get a firm understanding, I’d highly suggest <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" data-href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" class="markup--anchor markup--p-anchor" rel="nofollow">reading this article</a> which does a great job of explaining with awesome graphics. But this stuff really isn’t all that complicated.</p><p name="79ec" id="79ec" class="graf--p graf-after--p">Monads are pretty interesting though. Monads can be thought of as a container for a value, and to open up the container and do something to the value, you need to <em class="markup--em markup--p-em">map</em> over it. Here’s a simple example:</p><pre name="48e9" id="48e9" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">// monad</strong><br>list = [-1,0,1]<br>list.map(inc) // =&gt; [0,1,2]<br>list.map(isZero) // =&gt; [false, true, false]</pre><p name="bb13" id="bb13" class="graf--p graf-after--pre">The important thing about monads and functors is that mathematicians have been researching these ideas in <a href="https://en.wikipedia.org/wiki/Category_theory" data-href="https://en.wikipedia.org/wiki/Category_theory" class="markup--anchor markup--p-anchor" rel="nofollow">category theory</a>. This provides us not only a framework for understanding programs, but <a href="https://en.wikipedia.org/wiki/Monad_%28category_theory%29#Algebras_for_a_monad" data-href="https://en.wikipedia.org/wiki/Monad_%28category_theory%29#Algebras_for_a_monad" class="markup--anchor markup--p-anchor" rel="nofollow">algebraic theorems and proofs</a> we can use to statically analyze and optimize our code when it’s compiled. This is one of the main benefits of Haskell — the <a href="https://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler" data-href="https://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler" class="markup--anchor markup--p-anchor" rel="nofollow">Glasgow Haskell Compiler</a> is a feat of human ingenuity.</p><p name="cdda" id="cdda" class="graf--p graf-after--p">There are all kinds of theorems and identities expressed in category theory. For example, here’s a simple identity:</p><pre name="e247" id="e247" class="graf--pre graf-after--p">list.map(inc).map(isZero) // =&gt; [true, false, false]<br>list.map(compose(isZero, inc)) // =&gt; [true, false, false]</pre><p name="11ff" id="11ff" class="graf--p graf-after--pre">When <em class="markup--em markup--p-em">map</em> is compiled, it uses an efficient while loop. In general this is a <a href="https://en.wikipedia.org/wiki/Computational_complexity_theory" data-href="https://en.wikipedia.org/wiki/Computational_complexity_theory" class="markup--anchor markup--p-anchor" rel="nofollow">O(n) operation (linear time)</a>, but there is still overhead associated with incrementing the pointer to the next item in the list. So the second version is actually twice as performant. These are the kind of transformations that Haskell does to your code at compile-time to make it blazingly fast — and there’s a really cool trick to doing this that I’ll explain later.</p><p name="895f" id="895f" class="graf--p graf-after--p">To expand on monads just a little, there’s a very interesting monad called the <em class="markup--em markup--p-em">Maybe</em> monad (sometimes called <em class="markup--em markup--p-em">Option</em> or <em class="markup--em markup--p-em">Optional</em> in Swift). In Haskell, theres no such thing as <em class="markup--em markup--p-em">null</em> or <em class="markup--em markup--p-em">undefined</em>. To express something as being potentially <em class="markup--em markup--p-em">null</em>, you need to wrap it in a monad so the Haskell compiler knows what to do with it.</p><p name="8750" id="8750" class="graf--p graf-after--p">The <em class="markup--em markup--p-em">Maybe</em> monad is a <a href="https://en.wikipedia.org/wiki/Union_type" data-href="https://en.wikipedia.org/wiki/Union_type" class="markup--anchor markup--p-anchor" rel="nofollow">union type</a> that’s either <em class="markup--em markup--p-em">Nothing</em> or <em class="markup--em markup--p-em">Just something</em>. In Haskell you’d define a <em class="markup--em markup--p-em">Maybe </em>like this:</p><pre name="573b" id="573b" class="graf--pre graf-after--p">type Maybe = Nothing | Just x</pre><p name="220e" id="220e" class="graf--p graf-after--pre">The lowercase <em class="markup--em markup--p-em">x</em> just means any other type.</p><p name="89a6" id="89a6" class="graf--p graf-after--p">Being a monad, you can&nbsp;.<em class="markup--em markup--p-em">map()</em> over a <em class="markup--em markup--p-em">Maybe</em> to change the value it contains! When you map over a <em class="markup--em markup--p-em">Maybe</em>, if it of type <em class="markup--em markup--p-em">Just</em>, then we apply the function to the value and returns a new <em class="markup--em markup--p-em">Just</em> with that new value. If a the <em class="markup--em markup--p-em">Maybe</em> is of type <em class="markup--em markup--p-em">Nothing</em>, then we return <em class="markup--em markup--p-em">Nothing</em>. In Haskell, the syntax is quite elegant and uses pattern matching, but in JavaScript you might use a <em class="markup--em markup--p-em">Maybe </em>like this:</p><pre name="319b" id="319b" class="graf--pre graf-after--p">const x = Maybe.Just(10)<br>const n = x.map(inc)<br>n.isJust() // true<br>n.value() // 11</pre><pre name="548f" id="548f" class="graf--pre graf-after--pre">const x= Maybe.Nothing<br>const n = x.map(inc) // no error!<br>n.isNothing // true </pre><p name="afec" id="afec" class="graf--p graf-after--pre">This monad may not seem terribly useful in your Javascript code, but its interesting to see why its so useful in Haskell. <strong class="markup--strong markup--p-strong">Haskell requires you to define what to do in every edge-case of your program, otherwise it won’t compile.</strong> When you make an HTTP request, you get back a <em class="markup--em markup--p-em">Maybe</em> type because the request may fail and return nothing. And if you didn’t handle the case in which the request failed, then your program won’t compile. This basically means that it’s impossible to get runtime errors. Maybe your code does the wrong thing, but it doesn’t just magically break like things tend to do in Javascript.</p><blockquote name="214b" id="214b" class="graf--blockquote graf-after--p">This is a big selling point for using Elm. The type system and compiler enforces that your program will run without runtime errors.</blockquote><p name="0d30" id="0d30" class="graf--p graf-after--blockquote">Thinking about code in the context of monads and algebraic structures will help you define and understand your problem in a structured way. For example, an interesting extention of <em class="markup--em markup--p-em">Maybe</em> is the this <a href="http://fsharpforfunandprofit.com/rop/" data-href="http://fsharpforfunandprofit.com/rop/" class="markup--anchor markup--p-anchor" rel="nofollow">Railway-Oriented Programming</a> concept for error handling. And <a href="https://www.youtube.com/watch?v=XE692Clb5LU" data-href="https://www.youtube.com/watch?v=XE692Clb5LU" class="markup--anchor markup--p-anchor" rel="nofollow">observable streams</a> are monads as well for dealing with asynchronous events.</p><p name="2037" id="2037" class="graf--p graf-after--p">There are all kinds of fancy monads and many other words that I don’t myself fully understand. But to keep all the lingo consistent, there are specifications like <a href="https://github.com/fantasyland/fantasy-land" data-href="https://github.com/fantasyland/fantasy-land" class="markup--anchor markup--p-anchor" rel="nofollow">fantasy-land</a> and the <a href="https://wiki.haskell.org/Typeclassopedia" data-href="https://wiki.haskell.org/Typeclassopedia" class="markup--anchor markup--p-anchor" rel="nofollow">typeclassopedia</a> which try to unify different concepts in category theory for the purpose of writing idiomatic functional code.</p><h4 name="975a" id="975a" class="graf--h4 graf-after--p">Referential Transparency and Immutability</h4><p name="1f10" id="1f10" class="graf--p graf-after--h4">Another implication of leveraging all this category theory and lambda calculus stuff is <a href="https://en.wikipedia.org/wiki/Referential_transparency" data-href="https://en.wikipedia.org/wiki/Referential_transparency" class="markup--anchor markup--p-anchor" rel="nofollow">referential transparency</a>. Its really hard for mathematicians to analyze logical programs when <em class="markup--em markup--p-em">two things that are the same aren’t equal to each other.</em> This is an issue all over the place in Javascript.</p><pre name="09e1" id="09e1" class="graf--pre graf-after--p">{} == {} // false<br>[] == [] // false<br>[1,2] == [1,2] // false</pre><p name="a048" id="a048" class="graf--p graf-after--pre">Now imagine having to do math in a world without referential transparency. You wouldn’t be able to write proofs that say that an empty array is the same things as an empty array. What should matter is only the <em class="markup--em markup--p-em">value</em> of the array, not the reference pointer to the array. And so functional programming languages resort to using deep-equals to compare values. But this isn’t terribly performant, so there are some neat tricks to make this comparison quicker that leverages references.</p><p name="6636" id="6636" class="graf--p graf-after--p">Before moving on, I just want to make one thing clear: in functional programming, you cannot mutate a variable without changing its reference. Otherwise, the function performing the mutation would be impure! Thus, you can assure that if two variables are referentially equal, their values must be equal as well. And since we can’t mutate variables in-place, then we have to copy those values into a new memory location every time we want to transform it. This is a huge performance loss and results in <a href="https://en.wikipedia.org/wiki/Thrashing_%28computer_science%29" data-href="https://en.wikipedia.org/wiki/Thrashing_%28computer_science%29" class="markup--anchor markup--p-anchor" rel="nofollow">garbage thrashing</a>. But the solution is using <a href="https://en.wikipedia.org/wiki/Persistent_data_structure" data-href="https://en.wikipedia.org/wiki/Persistent_data_structure" class="markup--anchor markup--p-anchor" rel="nofollow">structural sharing (persistent data structures)</a>.</p><p name="165d" id="165d" class="graf--p graf-after--p">A simple example of structural sharing is a <a href="https://en.wikipedia.org/wiki/Linked_list" data-href="https://en.wikipedia.org/wiki/Linked_list" class="markup--anchor markup--p-anchor" rel="nofollow">linked list</a>. Suppose you only keep a reference to the end of the list. When comparing two lists, you can first start by seeing if the ends are referentially equal. This is a nice shortcut because if they are equal, then you’re done — the two lists are the same! Otherwise, you’ll have to start iterating through the items in each list to see if their values are equal. To efficiently add a value to this list, rather than copying entire the list into a new set of memory, you can simply add a link to a new node and keep track of the reference at the new tip. Thus, we’ve structurally shared the previous data structure in a new data structure with a new reference and we’ve persisted the previous data structure as well.</p><p name="57e1" id="57e1" class="graf--p graf-after--p">The generalized data structure for doing these immutable data transformations is called a <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie" data-href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie" class="markup--anchor markup--p-anchor" rel="nofollow">hash array mapped trie</a> (HAMT). This is exactly what <a href="https://facebook.github.io/immutable-js/" data-href="https://facebook.github.io/immutable-js/" class="markup--anchor markup--p-anchor" rel="nofollow">Immutable.js</a> and <a href="https://github.com/swannodette/mori" data-href="https://github.com/swannodette/mori" class="markup--anchor markup--p-anchor" rel="nofollow">Mori.js</a> do. Both Clojurescript and Haskell have this built into the compiler, although I’m not sure it’s implemented in Elm yet.</p><p name="6850" id="6850" class="graf--p graf-after--p">Using immutable data structures can give you performance gains, and help keep your sanity. <a href="http://facebook.github.io/react/" data-href="http://facebook.github.io/react/" class="markup--anchor markup--p-anchor" rel="nofollow">React</a> assumes <em class="markup--em markup--p-em">props</em> and <em class="markup--em markup--p-em">state</em> are always immutable so it an do an efficient check to see if the previous <em class="markup--em markup--p-em">props</em> and <em class="markup--em markup--p-em">state</em> are referentially equal to the next <em class="markup--em markup--p-em">props</em> and <em class="markup--em markup--p-em">state</em> before unnecessarily re-rendering. And in other circumstance, using immutable data simply helps to ensure that values aren’t changing without you realizing it.</p><h4 name="1f5d" id="1f5d" class="graf--h4 graf-after--p">Lazy Evaluation</h4><p name="afa0" id="afa0" class="graf--p graf-after--h4"><a href="https://en.wikipedia.org/wiki/Lazy_evaluation" data-href="https://en.wikipedia.org/wiki/Lazy_evaluation" class="markup--anchor markup--p-anchor" rel="nofollow">Lazy evaluation</a> is sort of a general term that covers more specific concepts like <a href="https://en.wikipedia.org/wiki/Thunk" data-href="https://en.wikipedia.org/wiki/Thunk" class="markup--anchor markup--p-anchor" rel="nofollow">thunks</a> and <a href="https://en.wikipedia.org/wiki/Generator_%28computer_programming%29" data-href="https://en.wikipedia.org/wiki/Generator_%28computer_programming%29" class="markup--anchor markup--p-anchor" rel="nofollow">generators</a>. Lazy evaluation means exactly what you think it does: don’t do something until you absolutely have to, be lazy and procrastinate as long as possible. One analogy is to suppose you have a large, possibly infinite, amount of dishes to wash. Rather than put all the dishes in the sink and wash them at once, let’s be lazy and just take one dish at a time.</p><p name="e011" id="e011" class="graf--p graf-after--p">In Haskell, the true essence lazy evaluation is a little easier to understand, so I’m going to start there. First, we need to understand <a href="https://en.wikipedia.org/wiki/Evaluation_strategy" data-href="https://en.wikipedia.org/wiki/Evaluation_strategy" class="markup--anchor markup--p-anchor" rel="nofollow">how programs evaluate</a>. Pretty much every language you’re used to uses <em class="markup--em markup--p-em">innermost reduction</em>. Innermost reduction looks like this:</p><pre name="9fce" id="9fce" class="graf--pre graf-after--p">square(3 + 4)<br>square(7) // evaluated the innermost expression<br>7 * 7<br>49</pre><p name="25f8" id="25f8" class="graf--p graf-after--pre">This is a sane and reasonable way of evaluating programs. But now, let’s consider outermost reduction:</p><pre name="c451" id="c451" class="graf--pre graf-after--p">square(3 + 4)<br>(3 + 4) * (3 + 4) // evaluated the outermost expression<br>7 * (3 + 4)<br>7 * 7<br>49</pre><p name="ac5f" id="ac5f" class="graf--p graf-after--pre">Outermost is clearly less efficient — we’ve had to compute 3 + 4 twice, so the program took 5 steps instead of 4. This is no good. But <strong class="markup--strong markup--p-strong">Haskell keeps a reference to each expression and shares these references as they’re passed down to parent expressions through the outermost reduction.</strong> Thus, when 3 + 4 is evaluated the first time, the reference to this expression now points to the expression, 7. Thus we get to skip the duplicate step.</p><pre name="2fda" id="2fda" class="graf--pre graf-after--p">square(3 + 4)<br>(3 + 4) * (3 + 4) // evaluated the outermost expression<br>7 * 7 // both reduced at the same time due to reference sharing<br>49</pre><blockquote name="62d6" id="62d6" class="graf--blockquote graf-after--pre">Fundamentally, lazy evaluation is outermost evaluation with reference sharing.</blockquote><p name="c904" id="c904" class="graf--p graf-after--blockquote">Haskell does all this stuff under the hood for you, and what that means is you can define things like infinite lists. For example, you can recursively define an infinite list of ones as 1 joined with itself.</p><pre name="bc9c" id="bc9c" class="graf--pre graf-after--p">ones = 1 : ones</pre><p name="483c" id="483c" class="graf--p graf-after--pre">Suppose you have a function <em class="markup--em markup--p-em">take(n, list) </em>which takes the first n elements of a list. If we used innermost reduction, we’d recursively evaluate list forever, because it’s infinite. But instead, with outermost reduction, we lazily evaluate ones for just as many ones as we need!</p><p name="339f" id="339f" class="graf--p graf-after--p">However, since JavaScript and most other programming languages use innermost reduction, the only way we can replicate these constructs is by treating arrays as functions. For example:</p><pre name="3388" id="3388" class="graf--pre graf-after--p">const makeOnes = () =&gt; {next: () =&gt; 1}<br>ones = makeOnes()<br>result.next() // =&gt; 1<br>result.next() // =&gt; 1</pre><p name="7ff5" id="7ff5" class="graf--p graf-after--pre">Now we’ve effectively created a lazily evaluated infinite list based on the same recursive definition. Lets create an infinite list of natural numbers:</p><pre name="7fa0" id="7fa0" class="graf--pre graf-after--p">const makeNumbers = () =&gt; {<br>  let n = 0<br>  return {next: () =&gt; {<br>    n += 1<br>    return n<br>  }<br>}<br>numbers = makeNumbers()<br>numbers.next() // 1<br>numbers.next() // 2<br>numbers.next() // 3</pre><p name="dda8" id="dda8" class="graf--p graf-after--pre">In ES2015, there’s actually a standard for this and they’re called <a href="https://en.wikipedia.org/wiki/Function_generator" data-href="https://en.wikipedia.org/wiki/Function_generator" class="markup--anchor markup--p-anchor" rel="nofollow">function generators</a>.</p><pre name="0c5b" id="0c5b" class="graf--pre graf-after--p">function* numbers() {<br>  let n = 0<br>  while(true) {<br>    n += 1<br>    yield n <br>  }<br>}</pre><p name="716b" id="716b" class="graf--p graf-after--pre">Laziness can give you huge performance gains. For example, check out <a href="http://danieltao.com/lazy.js/" data-href="http://danieltao.com/lazy.js/" class="markup--anchor markup--p-anchor" rel="nofollow">Lazy.js operations per second compared to Underscore and Lodash</a>:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="34e8" id="34e8" class="graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked"><div class="aspectRatioPlaceholder-fill"></div><div class="progressiveMedia js-progressiveMedia graf-image is-canvasLoaded" data-image-id="1*gmsdj0qNqAbgxIlqO089dw.png" data-width="1045" data-height="429" data-action="zoom" data-action-value="1*gmsdj0qNqAbgxIlqO089dw.png" data-scroll="native"><img src="https://cdn-images-2.medium.com/freeze/max/30/1*gmsdj0qNqAbgxIlqO089dw.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail"><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-2.medium.com/max/1200/1*gmsdj0qNqAbgxIlqO089dw.png" src="https://cdn-images-2.medium.com/max/1200/1*gmsdj0qNqAbgxIlqO089dw.png"><noscript class="js-progressiveMedia-inner">&lt;img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-2.medium.com/max/1200/1*gmsdj0qNqAbgxIlqO089dw.png"&gt;</noscript></div></div></figure></div><div class="section-inner layoutSingleColumn"><p name="9e05" id="9e05" class="graf--p graf-after--figure">Here’s a great example of why that is (<a href="http://danieltao.com/lazy.js/" data-href="http://danieltao.com/lazy.js/" class="markup--anchor markup--p-anchor" rel="nofollow">given by the Lazy.js website</a>). Suppose you have a huge array of people and you want to perform some transformations on it:</p><pre name="89d7" id="89d7" class="graf--pre graf-after--p">const results = _.chain(people)<br>  .pluck('lastName')<br>  .filter((name) =&gt; name.startsWith('Smith'))<br>  .take(5)<br>  .value()</pre><p name="b3a6" id="b3a6" class="graf--p graf-after--pre">The naïve way of doing this would be to pluck all the lastNames off, filter the entire array, and then take just the first 5. This is what <a href="http://underscorejs.org/" data-href="http://underscorejs.org" class="markup--anchor markup--p-anchor" rel="nofollow">Underscore.js</a> and most other libraries do. But with generators, we can lazily evaluate the expression by going one value at a time until we have 5 last names that start with “Smith”.</p><p name="702e" id="702e" class="graf--p graf-after--p">What’s amazing about Haskell is that this is all baked into the language by using outermost reduction and reference sharing. Every list is inherently lazy. In Javascript, you should probably just use Lazy.js, but if you wanted to create something like this of your own, you just need to understand that each step above returns a new generator. To get values out of a generator, you need to ask for them by calling&nbsp;<em class="markup--em markup--p-em">.next().</em> The <em class="markup--em markup--p-em">chain</em> method turns the <em class="markup--em markup--p-em">people</em> array into a generator, and each transformation accepts a generator and returns another generator. Then, when you call&nbsp;<em class="markup--em markup--p-em">.value()</em> it simply calls&nbsp;<em class="markup--em markup--p-em">.next()</em> repetitively until there are no more values left. And&nbsp;<em class="markup--em markup--p-em">.take(5)</em> will make sure that you aren’t processing more values than you need to!</p><p name="3286" id="3286" class="graf--p graf-after--p">Now remember that theorem earlier:</p><pre name="0c32" id="0c32" class="graf--pre graf-after--p">list.map(inc).map(isZero) // =&gt; [false, true, false]<br>list.map(compose(isZero, inc)) // =&gt; [false, true, false]</pre><p name="2c34" id="2c34" class="graf--p graf-after--pre">Lazy evaluation, inherently does these kind of optimizations for you.</p><h4 name="99c3" id="99c3" class="graf--h4 graf-after--p">Clojure Patterns and Features</h4><p name="5646" id="5646" class="graf--p graf-after--h4">I’ve talked a lot about Haskell so I want to explain where Clojure fits in to all of this. Clojure has referential transparency, immutable data types, and you cannot mutate variables in-place except for special transactional types called <em class="markup--em markup--p-em">atoms</em>. This is incredibly convenient sometimes when compared to Haskell, where you would be forced to scan values over a stream simply to record values in an associative array to recall elsewhere. Clojure also does not have a strong type system or an insanely powerful compiler like the <a href="https://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler" data-href="https://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler" class="markup--anchor markup--p-anchor" rel="nofollow">Glasgow Haskell Compiler</a>. And there is such thing as null in Clojure. That said, functional patterns are strongly encouraged and hard not to use in Clojure.</p><p name="773e" id="773e" class="graf--p graf-after--p">There are two things about Clojure that really stand out to me though: <strong class="markup--strong markup--p-strong">Everything is a primative data type in Clojure</strong>, called <a href="https://github.com/edn-format/edn" data-href="https://github.com/edn-format/edn" class="markup--anchor markup--p-anchor" rel="nofollow">EDN</a> — the Clojure version of JSON. Rather than having objects and types, everything is just some primitive data structure that’s interpreted however you want. For example, in JavaScript, we have native Date objects. But what happens when you want to serialize a date to JSON? Well you need to create your own custom serializer/deserializer. In Clojure, you might express a date as an associative array with a timestamp and a timezone (unless you’re using the Java implementation). Any string formatting functions just assume the same data structure. So in Clojure, there’s a strong emphasis on data, data transformations, and data processing. <em class="markup--em markup--p-em">Everything is data.</em></p><p name="f06c" id="f06c" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">The other really cool thing about Clojure is that code is data</strong>. Clojure is a <a href="https://en.wikipedia.org/wiki/Lisp_%28programming_language%29" data-href="https://en.wikipedia.org/wiki/Lisp_%28programming_language%29" class="markup--anchor markup--p-anchor" rel="nofollow">Lisp</a> which stands for <em class="markup--em markup--p-em">list processing</em>. The language is just an interpretation of lists where the first item in a list is a function and the rest of the items are arguments — which is why they like to say <a href="http://danthedev.com/2015/09/09/lisp-in-your-language" data-href="http://danthedev.com/2015/09/09/lisp-in-your-language" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">there’s a Lisp in every language</em></a><em class="markup--em markup--p-em">.</em> What’s so cool about Lisps, though, is you can create insanely powerful <a href="https://en.wikipedia.org/wiki/Macro_%28computer_science%29" data-href="https://en.wikipedia.org/wiki/Macro_%28computer_science%29" class="markup--anchor markup--p-anchor" rel="nofollow">macros</a>. The macros most people are used to are <em class="markup--em markup--p-em">text substitution </em>macros, where you generate code using some kind of string template. And there’s a cool library for doing this in Javascript called <a href="http://sweetjs.org/" data-href="http://sweetjs.org" class="markup--anchor markup--p-anchor" rel="nofollow">Sweetjs</a>. But in Clojure, since the code itself is just a list, you can inspect the code as a list at compile-time, transform the code, and then evaluate it! This is really convenient for wiring up repetitive boilerplate and <strong class="markup--strong markup--p-strong">allows you to essentially create whatever syntax you want to express something</strong>. To do the same thing in JavaScript, you’d need to get very familiar with <a href="https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/plugin-handbook.md" data-href="https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/plugin-handbook.md" class="markup--anchor markup--p-anchor" rel="nofollow">Babel Plugins and the JavaScript Abstract Syntax Tree (AST)</a> and create your own transpiler. But in Clojure, the AST is just a list!</p><p name="21f1" id="21f1" class="graf--p graf-after--p">One of the big features of Clojure is the <a href="http://www.braveclojure.com/core-async/" data-href="http://www.braveclojure.com/core-async/" class="markup--anchor markup--p-anchor" rel="nofollow">core.async</a> library for handling asynchronous communication, and it has a beautiful way of using macros. In the following example, we create a channel, and the <em class="markup--em markup--p-em">go</em> function is actually a macro.</p><pre name="cfca" id="cfca" class="graf--pre graf-after--p">(def echo-chan (chan))<br>(go (println (&lt;! echo-chan)))<br>(&gt;!! echo-chan "ketchup")<br>; prints ketchup</pre><p name="d13b" id="d13b" class="graf--p graf-after--pre">What’s amazing here is that <em class="markup--em markup--p-em">go</em> is actually interpretting its argument as a list to generate a bunch of nasty async code that nobody wants to write. It’s looking for <em class="markup--em markup--p-em">&lt;! </em>which is a symbol for essentially subscribing to the channel. Then it generates some code that does the job. Look at all this nasty code that we don’t have to write or deal with:</p><pre name="bca4" id="bca4" class="graf--pre graf-after--p">user=&gt; (macroexpand ‘(go (println (&lt;! echo-chan))))<br>(let* [c__6888__auto__ (clojure.core.async/chan 1) captured-bindings__6889__auto__ (clojure.lang.Var/getThreadBindingFrame)] (clojure.core.async.impl.dispatch/run (clojure.core/fn [] (clojure.core/let [f__6890__auto__ (clojure.core/fn state-machine__6712__auto__ ([] (clojure.core.async.impl.ioc-macros/aset-all! (java.util.concurrent.atomic.AtomicReferenceArray. 8) 0 state-machine__6712__auto__ 1 1)) ([state_8650] (clojure.core/let [old-frame__6713__auto__ (clojure.lang.Var/getThreadBindingFrame) ret-value__6714__auto__ (try (clojure.lang.Var/resetThreadBindingFrame (clojure.core.async.impl.ioc-macros/aget-object state_8650 3)) (clojure.core/loop [] (clojure.core/let [result__6715__auto__ (clojure.core/case (clojure.core/int (clojure.core.async.impl.ioc-macros/aget-object state_8650 1)) 1 (clojure.core/let [inst_8644 println inst_8645 echo-chan state_8650 (clojure.core.async.impl.ioc-macros/aset-all! state_8650 7 inst_8644)] (clojure.core.async.impl.ioc-macros/take! state_8650 2 inst_8645)) 2 (clojure.core/let [inst_8644 (clojure.core.async.impl.ioc-macros/aget-object state_8650 7) inst_8647 (clojure.core.async.impl.ioc-macros/aget-object state_8650 2) inst_8648 (inst_8644 inst_8647)] (clojure.core.async.impl.ioc-macros/return-chan state_8650 inst_8648)))] (if (clojure.core/identical? result__6715__auto__ :recur) (recur) result__6715__auto__))) (catch java.lang.Throwable ex__6716__auto__ (clojure.core.async.impl.ioc-macros/aset-all! state_8650 clojure.core.async.impl.ioc-macros/CURRENT-EXCEPTION ex__6716__auto__) (clojure.core.async.impl.ioc-macros/process-exception state_8650) :recur) (finally (clojure.lang.Var/resetThreadBindingFrame old-frame__6713__auto__)))] (if (clojure.core/identical? ret-value__6714__auto__ :recur) (recur state_8650) ret-value__6714__auto__)))) state__6891__auto__ (clojure.core/-&gt; (f__6890__auto__) (clojure.core.async.impl.ioc-macros/aset-all! clojure.core.async.impl.ioc-macros/USER-START-IDX c__6888__auto__ clojure.core.async.impl.ioc-macros/BINDINGS-IDX captured-bindings__6889__auto__))] (clojure.core.async.impl.ioc-macros/run-state-machine-wrapped state__6891__auto__)))) c__6888__auto__)</pre><h4 name="111c" id="111c" class="graf--h4 graf-after--pre">Conclusion</h4><p name="b4af" id="b4af" class="graf--p graf-after--h4">That’s basically everything I’ve learned about functional programming in the last few months. I hope that really helps people, especially the JavaScript community, write better code and inevitably create even more awesome things!</p><p name="c3c2" id="c3c2" class="graf--p graf-after--p">As for the never-ending debate on Haskell vs Clojure, I think it’s impossible to say which is <em class="markup--em markup--p-em">better</em> because they’re different. Haskell is the the fundamentals of functional programming. Haskell people literally call themselves programming <em class="markup--em markup--p-em">fundamentalists.</em> Haskell is rigid, specific, bulletproof, and ridiculously fast and compact. Clojure is malleable, abstract, and empowering. You can do anything in Clojure because its written on the <a href="https://en.wikipedia.org/wiki/Java_virtual_machine" data-href="https://en.wikipedia.org/wiki/Java_virtual_machine" class="markup--anchor markup--p-anchor" rel="nofollow">JVM</a> (and you can do pretty much anything in Java). In Clojure you can build off decades of work in tried and tested Java algorithms. Clojure also has a unique culture of creative programmers behind it with really cool libraries like <a href="http://overtone.github.io/" data-href="http://overtone.github.io" class="markup--anchor markup--p-anchor" rel="nofollow">Overtone</a> and <a href="http://quil.info/" data-href="http://quil.info" class="markup--anchor markup--p-anchor" rel="nofollow">Quill</a>.</p><p name="10d2" id="10d2" class="graf--p graf-after--p">As far as the Javascript world, I would love to see things moving more into the realm of pure functions. I don’t ever want to see <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">this</em></a> again. And let’s also get in the habit of only using <em class="markup--em markup--p-em">const</em> types rather than the mutable <em class="markup--em markup--p-em">var </em>or <em class="markup--em markup--p-em">let</em>.</p><p name="e87c" id="e87c" class="graf--p graf-after--p">Two of my absolute favorite JavaScript libraries are <a href="http://ramdajs.com/0.19.1/docs/" data-href="http://ramdajs.com/0.19.1/docs/" class="markup--anchor markup--p-anchor" rel="nofollow">Ramda</a> and <a href="https://github.com/paldepind/flyd" data-href="https://github.com/paldepind/flyd" class="markup--anchor markup--p-anchor" rel="nofollow">Flyd</a>. But Ramda isn’t lazy and doesn’t play nice with <a href="https://facebook.github.io/immutable-js/" data-href="https://facebook.github.io/immutable-js/" class="markup--anchor markup--p-anchor" rel="nofollow">Immutable.js</a>. I’d really like to see a library that combines all of these concepts — persistent / shared / immutable data structures with curried, lazily evaluated, composable utility functions.</p><p name="8bf9" id="8bf9" class="graf--p graf-after--p">And I’d also like to see libraries using a more consistent language for describing things — the new ES2015 <em class="markup--em markup--p-em">Promises</em> API, for example, uses&nbsp;<em class="markup--em markup--p-em">.then</em> as opposed to&nbsp;.<em class="markup--em markup--p-em">map</em> even though a <em class="markup--em markup--p-em">Promise </em>is totally a monad! This means, that you can’t use Ramda for processing data inside native promises because <em class="markup--em markup--p-em">R.map</em> won’t work. I think the aptly named <a href="https://github.com/fantasyland/fantasy-land" data-href="https://github.com/fantasyland/fantasy-land" class="markup--anchor markup--p-anchor" rel="nofollow">Fantasyland specification</a> is a grand ideal because it tries to unify the language that all programming data structures speak. If all these libraries like Ramda, Lodash, Lazy.js, Immutable.js, and even the native data primitives like promises use this common language, we can use reuse way more code. You could swap out your native Javascript arrays for Immutable.js lists without having to rewrite all the data processing code you’re using in Ramda or Lazy.js.</p><p name="9f2a" id="9f2a" class="graf--p graf-after--p">Anyways, I hope you enjoyed reading this. Please let me know if you didn’t understand something or if something made a lot of sense to you so I can improve my writing/mind-barfing — <em class="markup--em markup--p-em">ccorcos@gmail.com</em>.</p><p name="004c" id="004c" class="graf--p graf-after--p graf--last">Happy Hacking</p></div></div></section>