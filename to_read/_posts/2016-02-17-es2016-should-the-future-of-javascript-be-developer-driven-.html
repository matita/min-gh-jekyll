---
title: "ES2016: Should the Future of JavaScript Be Developer-Driven?"
description: "Tim Severien and Moritz Kröger debate if the decision to rename ES2016 method Array.prototype.includes is good for the direction of the language as a whole."
link: "http://www.sitepoint.com/es2016-should-future-of-javascript-be-developer-driven/"
saved: "2016-02-17 16:45:11"
---

    <p>Recently, it was announced that the next version of JavaScript (ES2016) will be comprised of a <a href="https://ponyfoo.com/articles/es2016-features-and-ecmascript-as-a-living-standard">very small feature set</a>, namely <a href="https://github.com/tc39/Array.prototype.includes/">Array.prototype.includes</a> (which determines whether a specific value is included in an array or not) and the <a href="https://github.com/rwaldron/exponentiation-operator">exponentiation operator</a> (which raises a number to the power of an exponent). Considering the plethora of new features introduced by ES6, some people might be surprised at exactly how small a release ES2016 will be. Others, on the other hand, may be happy that there are only two new features to learn—a manageable goal by most people’s standards.</p>
<p>While ES2016 being so small caused a few raised eyebrows, it also highlighted another issue—that the <code class=" language-undefined">Array.prototype.includes</code> method was originally going to be named <code class=" language-undefined">Array.prototype.contains</code>, but it turns out that this name is not <a href="https://github.com/tc39/Array.prototype.includes/tree/b6671aec098db241ab2d27d7bc182cc8a074edef#status">web-compatible</a> (read it would have clashed with the MooTools library, potentially resulting in many broken websites).</p>
<p>And so it was renamed.</p>
<p>What we’re asking today is whether it is a good thing for the community to be driving the direction of the language like this, or whether it’s “kinda whack” that the spec was changed because of a library conflict. Two of our authors (<a href="http://www.sitepoint.com/author/mkroeger/">Moritz</a> and <a href="http://www.sitepoint.com/author/tseverien/">Tim</a>) take opposing viewpoints on this issue.</p>
<h2 id="timthespecshouldrulethelibrariesshouldobey">Tim: the Spec Should Rule, Libraries Should Obey</h2>
<p>If you ignore its quirks, JavaScript is easy to grasp and really flexible—it makes a great first language. It also makes a great second language. Many developers I know had history programming in other languages prior to writing JavaScript, and with Node becoming increasingly stable and better, I believe many others will follow.</p>
<p>It seems the programming world disagrees on naming a method to check whether an array item or substring exists in an array or string. C# and Java have <code class=" language-undefined">.contains()</code> for array-like and string classes, Ruby has <code class=" language-undefined">.include?()</code>, Python has the <code class=" language-undefined">in</code>-operator and PHP has the <code class=" language-undefined">in_array()</code> and <code class=" language-undefined">strstr()</code> functions. It’s kind of a mess. In JavaScript-land however, there’s jQuery, Underscore, MooTools and a bunch of other frameworks/libraries that all have <code class=" language-undefined">.contains()</code>. Perhaps we can speak of a little convention going on here.</p>
<blockquote>
<p>If they intend to take old libraries into account when naming APIs, I fear this is only the beginning of super weird names</p>
</blockquote>
<p>I get the philosophy that changes may break many websites and/or apps, but we have to realise that with the diversity of existing libraries, breaking changes will occur. I hate the thought we are willing to make design choices to dodge one bullet. It’s not that I disagree with the chosen name, but this philosophy may lead to bad design choices in the future if it may break <a href="http://trends.builtwith.com/javascript/MooTools">1% of the web</a> because of bad design choices on their part.</p>
<p>What bothers me more is inconsistency. This one change won’t turn JavaScript into another PHP, but TC39 should keep the standard high. The DOM specification, for example, includes <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/contains">Node.contains()</a>. Although one may argue that the currently implemented <code class=" language-undefined">.includes()</code> is part of JavaScript’s core while the DOM API is not, this is confusing when you’re building for the web, which seems the prior concern of choosing <code class=" language-undefined">.includes()</code> over <code class=" language-undefined">.contains()</code>.</p>
<p>I think TC39 should focus on keeping JavaScript neat. In other languages you can often build for and stick to a specific version. The web, however, doesn’t play nice with deprication or changes—every choice is permanent. Choosing between breaking 1% of the web using a poorly designed library vs. focus on the future and durability of the language, I’d rather choose the latter.</p>
<h2 id="moritzweshouldntbreakthewebjustbecauseofnamingpreferences">Moritz: We Shouldn’t Break the Web Just Because of Naming Preferences</h2>
<p>The web has always been about accessibility. A website written in old standards (e.g. XHTML 1.0) is still usable today and won’t crash your browser. JavaScript has almost become a necessity and powers a large fraction of what we call the internet. A good part—if not the most—of last year’s ECMAScript 2015 feature set is syntactical sugar, intended to provide backwards compatibility.</p>
<blockquote>
<p>The focus should be on fixing real language flaws and needs, not adopting more syntactic sugar from other languages.</p>
</blockquote>
<p>JavaScript hasn’t always been so feature-rich as it is today. With libraries and frameworks like Prototype, jQuery, MooTools and many more, the web community filled the gaps and needs themselves. Some of them became very popular, others vanished, but all of them eventually shaped the web—and language specifications.</p>
<p>Many of the latest JavaScript additions have just been an answer to what these libraries already provide. It only makes sense to take this into consideration when creating a new language feature. Hence, I am very happy to see the <a href="https://github.com/tc39">Technical Committee 39</a> renaming <code class=" language-undefined">Array.prototype.includes</code>.</p>
<p>As Tim already pointed out, naming a function that checks for the existence of an item, is an active discussion across the programming world. The DOM API started with the <code class=" language-undefined">contains()</code> naming schema (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/classList">Element.classList.contains()</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/contains">Node.contains()</a>), then the language specification changes an API to <code class=" language-undefined">includes()</code>, and the rest seems to proceed with the initial pattern: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/containsNode">Selection.containsNode()</a>. I also want JavaScript to be a consistent language, but we shouldn’t start to break the web just because of naming preferences. Consistency matters, but keeping the web accessible does more.</p>
<p>Besides that, I welcome the new release process of the ECMAScript specification. Not having a huge bundle of new features every year, will help developers to keep up with the language. Although, there should still be a rough plan of the direction ECMAScript is heading. Adding new features just to answer the needs of a <a href="http://www.2ality.com/2015/11/string-padding.html">current trend</a> will end in a bloated language. The focus should be on fixing real language flaws and <a href="https://github.com/tc39/ecmascript-asyncawait">needs</a>, not adopting more syntactic sugar from other languages.</p>
<h2 id="overtoyou">Over to You</h2>
<p>So there you have it. Should we stand firm and focus on the future and durability of the language we love, or should we avoid breaking the web over naming preferences?</p>
<p>There’s no denying that naming things is dificult. As the <a href="http://martinfowler.com/bliki/TwoHardThings.html">saying goes</a>, there are two hard things in computer science: cache invalidation, naming things, and off-by-one errors.</p>
<p>Which side of the debate do you fall on? We’d love to hear from you in the comments.</p>
  