---
title: "Choosing Vanilla JavaScript in 2016 — Vanilla JavaScript — Medium"
description: "ECMAScript’s latest spec makes a compelling case for developing without heavy libraries or frameworks."
link: "https://medium.com/vanilla-javascript/choosing-vanilla-javascript-in-2016-6f38a8302ee5#.51u87gid9"
saved: "2016-02-19 14:25:00"
---
<section name="335a" class=" section--body section--first"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner u-sizeFullWidth"><figure name="b05d" id="b05d" class="graf--figure graf--layoutFillWidth graf--first"><div class="aspectRatioPlaceholder is-locked"><div class="aspectRatioPlaceholder-fill"></div><div class="progressiveMedia js-progressiveMedia graf-image is-canvasLoaded is-imageLoaded" data-image-id="1*hsXt6Ohe-lVFGo6zF97Jvw.png" data-width="1920" data-height="400" data-scroll="native"><img src="https://cdn-images-2.medium.com/freeze/max/30/1*hsXt6Ohe-lVFGo6zF97Jvw.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail"><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-2.medium.com/max/2000/1*hsXt6Ohe-lVFGo6zF97Jvw.png" src="https://cdn-images-2.medium.com/max/2000/1*hsXt6Ohe-lVFGo6zF97Jvw.png"><noscript class="js-progressiveMedia-inner">&lt;img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-2.medium.com/max/2000/1*hsXt6Ohe-lVFGo6zF97Jvw.png"&gt;</noscript></div></div></figure></div><div class="section-inner layoutSingleColumn"><h3 name="f9e0" id="f9e0" class="graf--h3 graf-after--figure">Choosing Vanilla JavaScript in 2016</h3><h4 name="e6f1" id="e6f1" class="graf--h4 graf-after--h3">ECMAScript’s latest spec makes a compelling case for developing without heavy libraries or frameworks.</h4><p name="730e" id="730e" class="graf--p graf-after--h4"><strong class="markup--strong markup--p-strong">Update 1:</strong> This article is targeted at front-end devs that work in the browser, so my definition of “vanilla” JavaScript includes other APIs like the DOM (as the original <a href="http://vanilla-js.com/" data-href="http://vanilla-js.com" class="markup--anchor markup--p-anchor" rel="nofollow">vanilla-js.com</a> site does.) I apologize for the confusion this might have caused (“vanilla” means something different in Node.js-land.)</p><p name="8a13" id="8a13" class="graf--p graf-after--p graf--last"><strong class="markup--strong markup--p-strong">Update 2:</strong> I buried the lede a little so I want to make it clear that I’m advocating here for <em class="markup--em markup--p-em">responsible</em> library use. As the subtitle mentions, my aim is to get people using <em class="markup--em markup--p-em">heavy</em> libs and frameworks to reevaluate their needs in light of new features added to ECMAScript and the web platform. Sorry for the confusion!</p></div></div></section><section name="1b88" class=" section--body"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner layoutSingleColumn"><p name="60ac" id="60ac" class="graf--p graf--first">I’ve always loved the idea of <a href="http://vanilla-js.com/" data-href="http://vanilla-js.com/" class="markup--anchor markup--p-anchor" rel="nofollow">Vanilla JavaScript</a>, or the use of JavaScript without relying on heavy libraries or frameworks. <a href="http://www.nanigans.com/" data-href="http://www.nanigans.com/" class="markup--anchor markup--p-anchor" rel="nofollow">Where I work</a>, we make use of the following front-end technologies:</p><ul class="postList"><li name="3862" id="3862" class="graf--li graf-after--p"><a href="http://jquery.com/" data-href="http://jquery.com" class="markup--anchor markup--li-anchor" rel="nofollow">jQuery</a> for cross-browser DOM manipulation, animations, and AJAX</li><li name="ccf6" id="ccf6" class="graf--li graf-after--li"><a href="https://github.com/justjohn/twig.js/" data-href="https://github.com/justjohn/twig.js/" class="markup--anchor markup--li-anchor" rel="nofollow">Twig.js</a> for HTML templating</li><li name="b7da" id="b7da" class="graf--li graf-after--li"><a href="http://requirejs.org/" data-href="http://requirejs.org/" class="markup--anchor markup--li-anchor" rel="nofollow">RequireJS</a> for package and dependency management</li><li name="8a87" id="8a87" class="graf--li graf-after--li"><a href="http://lesscss.org/" data-href="http://lesscss.org/" class="markup--anchor markup--li-anchor" rel="nofollow">Less</a> for large-scale CSS management</li></ul><p name="9b84" id="9b84" class="graf--p graf-after--li">I thought it’d be an interesting thought experiment to see which of these could be replaced by pure-JavaScript equivalents.</p><p name="e1ad" id="e1ad" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Note:</strong> Whenever there’s an article about new JavaScript features, there’s a disclaimer about how you can’t use them yet (without <a href="https://github.com/samccone/The-cost-of-transpiling-es2015-in-2016" data-href="https://github.com/samccone/The-cost-of-transpiling-es2015-in-2016" class="markup--anchor markup--p-anchor" rel="nofollow">transpiling</a>) because of old browsers. Personally, I’m tired of seeing such disclaimers (and <em class="markup--em markup--p-em">especially</em> the associated “Gotcha!” comments if an article lacks one.)</p><p name="0b55" id="0b55" class="graf--p graf-after--p graf--last">The browser landscape is better than ever. Chrome and Firefox have accelerated release schedules and seamless update processes, and Microsoft has pledged that they want Edge to go the “evergreen” route too (though <a href="https://www.scirra.com/blog/173/just-how-evergreen-is-microsoft-edge" data-href="https://www.scirra.com/blog/173/just-how-evergreen-is-microsoft-edge" class="markup--anchor markup--p-anchor" rel="nofollow">it’s debatable if they’re there right now</a>.) The only outlier is Safari, but that topic <a href="http://nolanlawson.com/2015/06/30/safari-is-the-new-ie/" data-href="http://nolanlawson.com/2015/06/30/safari-is-the-new-ie/" class="markup--anchor markup--p-anchor" rel="nofollow">has been beaten to death</a> by this point.</p></div></div></section><section name="9c33" class=" section--body"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="4272" id="4272" class="graf--h4 graf--first">The basics: querySelectorAll and Promises</h4><p name="23a3" id="23a3" class="graf--p graf-after--h4">These are the oldest and most widely-implemented feature on this list, but they’re worth mentioning as part of the modern JavaScript coder’s toolbox.</p><p name="636a" id="636a" class="graf--p graf-after--p">For newbie coders and those who use jQuery mostly for DOM wrangling, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector" data-href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector" class="markup--anchor markup--p-anchor" rel="nofollow">document.querySelector</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll" data-href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll" class="markup--anchor markup--p-anchor" rel="nofollow">document.querySelectorAll</a> get you 90% of the way towards jQuery’s <a href="https://sizzlejs.com/" data-href="https://sizzlejs.com/" class="markup--anchor markup--p-anchor" rel="nofollow">Sizzle selector engine</a>. Past that, the DOM isn’t nearly as nice as jQuery makes things, but it’s far better than it was even a few years ago.</p><p name="09bd" id="09bd" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Who has it?</strong></p><ul class="postList"><li name="0e24" id="0e24" class="graf--li graf-after--p"><a href="http://caniuse.com/#feat=queryselector" data-href="http://caniuse.com/#feat=queryselector" class="markup--anchor markup--li-anchor" rel="nofollow">Literally everyone.</a> Even IE8.</li></ul><p name="c945" id="c945" class="graf--p graf-after--li">It’s weird to say, but <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" class="markup--anchor markup--p-anchor" rel="nofollow">Promises</a> are somewhat old-hat as far as this list goes. At time of writing, Chrome has had them for 15 whole versions!</p><pre name="fe97" id="fe97" class="graf--pre graf-after--p">var message = new Promise(function (resolve, reject) {<br>  getMessage(function (success, message) {<br>    if (success) {<br>      resolve(message);<br>    } else {<br>      reject(message);<br>    }<br>  });<br>});</pre><pre name="2f8b" id="2f8b" class="graf--pre graf-after--pre">message.then(function (message) {<br>  message += 'For the win!';<br>  displayMessage(message);<br>});</pre><p name="0198" id="0198" class="graf--p graf-after--pre">Code complexity-wise, it’s easy to hang yourself with all the rope that Promises give you, but they simplify so many use-cases that it’s easy to see why their spec was fast-tracked.</p><p name="9133" id="9133" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Who has it?</strong></p><ul class="postList"><li name="ce5c" id="ce5c" class="graf--li graf-after--p">Chrome 33+ / Opera 20+</li><li name="4b32" id="4b32" class="graf--li graf-after--li">Firefox 29+</li><li name="259b" id="259b" class="graf--li graf-after--li">Edge 12+</li><li name="a395" id="a395" class="graf--li graf-after--li graf--last">Safari 7.1+</li></ul></div></div></section><section name="65b5" class=" section--body"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="288b" id="288b" class="graf--h4 graf--first">Easy AJAX with the Fetch API</h4><p name="4dce" id="4dce" class="graf--p graf-after--h4">It’s no secret that using XMLHttpRequest just… <em class="markup--em markup--p-em">sucks.</em> <a href="http://www.html5rocks.com/en/tutorials/file/xhr2/" data-href="http://www.html5rocks.com/en/tutorials/file/xhr2/" class="markup--anchor markup--p-anchor" rel="nofollow">The sequel</a> is better, but still woefully ugly.</p><p name="94c6" id="94c6" class="graf--p graf-after--p">What is the Fetch API? At a high-level, it’s AJAX implemented as <a href="http://www.html5rocks.com/en/tutorials/es6/promises/" data-href="http://www.html5rocks.com/en/tutorials/es6/promises/" class="markup--anchor markup--p-anchor" rel="nofollow">Promises</a>. You know, like how jQuery works.</p><p name="cdee" id="cdee" class="graf--p graf-after--p">XMLHttpRequest Level 2:</p><pre name="c33e" id="c33e" class="graf--pre graf-after--p">var xhr = new XMLHttpRequest();<br>xhr.open('GET', '/user/1', true);<br>xhr.onreadystatechange = function () {<br>  if (this.readyState === 4) {<br>    var user = JSON.parse(xhr.responseText);<br>  }<br>};<br>xhr.send();</pre><p name="2efb" id="2efb" class="graf--p graf-after--pre">jQuery:</p><pre name="70d3" id="70d3" class="graf--pre graf-after--p">$.ajax('/user/1')<br>.done(function (data) {<br>  var user = data;<br>});</pre><p name="0e0f" id="0e0f" class="graf--p graf-after--pre">Fetch:</p><pre name="946b" id="946b" class="graf--pre graf-after--p">fetch('/user/1')<br>.then(function (response) {<br>  return response.json();<br>})<br>.then(function<strong class="markup--strong markup--pre-strong"> </strong>(data) {<br>  var user = data;<br>});</pre><figure name="fea0" id="fea0" class="graf--figure graf-after--pre"><div class="aspectRatioPlaceholder is-locked"><div class="aspectRatioPlaceholder-fill"></div><img class="graf-image" data-image-id="1*XaE6F2MCYOJIaC9t7tqf-A.gif" data-width="500" data-height="264" src="https://cdn-images-2.medium.com/max/800/1*XaE6F2MCYOJIaC9t7tqf-A.gif"></div></figure><p name="1af5" id="1af5" class="graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Who has it?</strong></p><ul class="postList"><li name="b265" id="b265" class="graf--li graf-after--p">Chrome 42+ / Opera 29+</li><li name="5800" id="5800" class="graf--li graf-after--li">Firefox 39+</li></ul><p name="1f88" id="1f88" class="graf--p graf-after--li graf--last"><a href="https://dev.windows.com/en-us/microsoft-edge/platform/status/fetchapi" data-href="https://dev.windows.com/en-us/microsoft-edge/platform/status/fetchapi" class="markup--anchor markup--p-anchor" rel="nofollow">Microsoft has indicated they intend to implement the Fetch API this year.</a> I couldn’t find any info on when Safari might implement it.</p></div></div></section><section name="a079" class=" section--body"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="aaef" id="aaef" class="graf--h4 graf--first">HTML templating with &lt;template&gt; and ECMAScript 2015 template strings</h4><p name="0953" id="0953" class="graf--p graf-after--h4"><a href="http://www.html5rocks.com/en/tutorials/webcomponents/template/" data-href="http://www.html5rocks.com/en/tutorials/webcomponents/template/" class="markup--anchor markup--p-anchor" rel="nofollow">The HTML5 &lt;template&gt; tag</a> has been around for a few years and is fairly well-known and implemented. Elements inside a &lt;template&gt; tag are considered inert and do not get rendered or instantiated. The pattern is that your JavaScript will clone the elements inside when it wants to render them:</p><pre name="d2e3" id="d2e3" class="graf--pre graf-after--p">&lt;template class="hello-template"&gt;<br>  &lt;div class="hello"&gt;<br>    Hello, world!<br>  &lt;/div&gt;<br>&lt;/template&gt;</pre><pre name="77a9" id="77a9" class="graf--pre graf-after--pre">&lt;script&gt;<br>  var helloTemplate = document.querySelector('.hello-template');<br>  var helloDiv = document.importNode(helloTemplate.content, true);<br>  document.querySelector('body').appendChild(helloDiv);<br>&lt;/script&gt;</pre><p name="d619" id="d619" class="graf--p graf-after--pre">It’s a little verbose but still useful when you have bits of reusable markup in your document. But what if you have bits of reusable markup in your code? <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings" class="markup--anchor markup--p-anchor" rel="nofollow">Template strings</a> to the rescue!</p><pre name="efdd" id="efdd" class="graf--pre graf-after--p">var firstName = 'Andrew';<br>var lastName = 'Wizard';<br>var fullName = `&lt;div class="full-name"&gt;<br>  &lt;em&gt;${firstName}&lt;/em&gt; &lt;strong&gt;${lastName}&lt;/strong&gt;<br>&lt;/div&gt;`;<br>document.querySelector('body').innerHTML = fullName;</pre><p name="30b9" id="30b9" class="graf--p graf-after--pre">Template strings are useful for a bunch of reasons:</p><ol class="postList"><li name="5ce8" id="5ce8" class="graf--li graf-after--p">They allow multi-line strings in JavaScript without hacks.</li><li name="07d0" id="07d0" class="graf--li graf-after--li">They allow easier variable use without concatenation.</li><li name="b426" id="b426" class="graf--li graf-after--li">The ${} substitution syntax can also evaluate any JavaScript expression, for instance 1 + 2.</li></ol><p name="7790" id="7790" class="graf--p graf-after--li">I haven’t played with template strings as much as I’ve wanted to, but I imagine it wouldn’t be hard to make a vanilla JavaScript equivalent of <a href="http://handlebarsjs.com/" data-href="http://handlebarsjs.com/" class="markup--anchor markup--p-anchor" rel="nofollow">Handlebars</a>. It’d be a server-side script that takes HTML files with ${} substitutions, wraps them in backticks (`), and outputs them as JavaScript modules (see the next section) ready for immediate use.</p><p name="97de" id="97de" class="graf--p graf-after--p">(<strong class="markup--strong markup--p-strong">Update:</strong> Some have commented that this could leave you open to XSS, which is what I get for not playing around with it as much as I’d like! Make sure you thoroughly vet your web apps for security holes, especially when using newer technologies.)</p><p name="b3d6" id="b3d6" class="graf--p graf-after--p">This is as close as browsers have ever come to native, external HTML templates, and every major browser supports it! I’m really excited about this part of the stack.</p><p name="badb" id="badb" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Who has it?<br></strong><a href="http://caniuse.com/#feat=template" data-href="http://caniuse.com/#feat=template" class="markup--anchor markup--p-anchor" rel="nofollow">Everybody has the &lt;template&gt; tag.</a> As for who supports template strings:</p><ul class="postList"><li name="bcb7" id="bcb7" class="graf--li graf-after--p">Chrome 41+ / Opera 28+</li><li name="8adb" id="8adb" class="graf--li graf-after--li">Edge 12+</li><li name="1cf5" id="1cf5" class="graf--li graf-after--li">Firefox 34+</li><li name="8c32" id="8c32" class="graf--li graf-after--li graf--last">Safari 9.0+</li></ul></div></div></section><section name="ad76" class=" section--body"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="f132" id="f132" class="graf--h4 graf--first">Package management with ECMAScript 2015 modules</h4><p name="52f8" id="52f8" class="graf--p graf-after--h4"><a href="http://exploringjs.com/es6/ch_modules.html" data-href="http://exploringjs.com/es6/ch_modules.html" class="markup--anchor markup--p-anchor" rel="nofollow">Modules</a> are the biggest reason I decided to write this article. (Although I’m cheating since they probably won’t be ready for use this year.) There are two types of JavaScript modules today:</p><ul class="postList"><li name="fba5" id="fba5" class="graf--li graf-after--p">Those that implement that <a href="http://requirejs.org/docs/whyamd.html" data-href="http://requirejs.org/docs/whyamd.html" class="markup--anchor markup--li-anchor" rel="nofollow">Asynchronous Module Definition</a> (AMD.) <a href="http://requirejs.org/" data-href="http://requirejs.org" class="markup--anchor markup--li-anchor" rel="nofollow">RequireJS</a> falls under this. AMD is more suited to browsers.</li><li name="28e9" id="28e9" class="graf--li graf-after--li">Those that implement the <a href="http://www.commonjs.org/" data-href="http://www.commonjs.org/" class="markup--anchor markup--li-anchor" rel="nofollow">CommonJS</a> format. <a href="https://nodejs.org/en/" data-href="https://nodejs.org/en/" class="markup--anchor markup--li-anchor" rel="nofollow">Node.js</a> <a href="https://www.npmjs.com/" data-href="https://www.npmjs.com/" class="markup--anchor markup--li-anchor" rel="nofollow">packages</a> implement this format, which is not well-suited to browsers.</li></ul><p name="d084" id="d084" class="graf--p graf-after--li">Native JavaScript modules take features from both and because of that they’re very robust.</p><pre name="456e" id="456e" class="graf--pre graf-after--p">import square from 'math';<br>console.log(square(12)); // 144</pre><p name="b9a0" id="b9a0" class="graf--p graf-after--pre"><a href="https://www.youtube.com/watch?v=nQJACVmankY" data-href="https://www.youtube.com/watch?v=nQJACVmankY" class="markup--anchor markup--p-anchor" rel="nofollow">How does that song go again?</a></p><ul class="postList"><li name="507f" id="507f" class="graf--li graf-after--p">You import a single method or an entire module.</li><li name="a657" id="a657" class="graf--li graf-after--li">You can designate a default export method.</li><li name="5515" id="5515" class="graf--li graf-after--li">You can export classes.</li><li name="0c41" id="0c41" class="graf--li graf-after--li">You can name imports <em class="markup--em markup--li-em">whatever you like.</em></li></ul><p name="00d8" id="00d8" class="graf--p graf-after--li">I feel like modules will be one of the biggest advances for JavaScript development in a long time. Aside from native dependency management being great on its own, the syntax is just far <em class="markup--em markup--p-em">cleaner</em> than AMD/RequireJS.</p><p name="d74c" id="d74c" class="graf--p graf-after--p">Some great reading on this exciting new tech:</p><ul class="postList"><li name="f387" id="f387" class="graf--li graf-after--p"><a href="http://benmccormick.org/2015/05/28/moving-past-requirejs/" data-href="http://benmccormick.org/2015/05/28/moving-past-requirejs/" class="markup--anchor markup--li-anchor" rel="nofollow">Moving Past RequireJS</a> by Ben McCormick</li><li name="e2d4" id="e2d4" class="graf--li graf-after--li"><a href="http://exploringjs.com/es6/ch_modules.html" data-href="http://exploringjs.com/es6/ch_modules.html" class="markup--anchor markup--li-anchor" rel="nofollow">Exploring ES6: Modules</a> by Dr. Axel Rauschmayer</li><li name="c1b6" id="c1b6" class="graf--li graf-after--li"><a href="https://addyosmani.com/writing-modular-js/" data-href="https://addyosmani.com/writing-modular-js/" class="markup--anchor markup--li-anchor" rel="nofollow">Writing Modular JavaScript With AMD, CommonJS &amp; ES Harmony</a> by Addy Osmani</li></ul><p name="a2f5" id="a2f5" class="graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Who has it?</strong></p><p name="7d21" id="7d21" class="graf--p graf-after--p graf--last">Nobody! Yet at least. <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-modules" data-href="http://www.ecma-international.org/ecma-262/6.0/#sec-modules" class="markup--anchor markup--p-anchor" rel="nofollow">The modules spec was included in ECMAScript 2015</a>, but browsers have been slow to tackle it. Last I heard, the holdup seems to be consternation over how the module loader should behave. Hopefully we start to see some implementations later this year — <a href="https://bugs.chromium.org/p/v8/issues/detail?id=1569#c8" data-href="https://bugs.chromium.org/p/v8/issues/detail?id=1569#c8" class="markup--anchor markup--p-anchor" rel="nofollow">they’re behind a feature flag in V8</a> (used by Chrome, Opera and Node.js) and <a href="https://blogs.windows.com/msedgedev/2016/02/03/2016-platform-priorities/" data-href="https://blogs.windows.com/msedgedev/2016/02/03/2016-platform-priorities/" class="markup--anchor markup--p-anchor" rel="nofollow">Microsoft has pegged it as a feature coming soon to Edge</a>.</p></div></div></section><section name="8925" class=" section--body"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="62f8" id="62f8" class="graf--h4 graf--first">On the style side: CSS variables</h4><p name="3d7d" id="3d7d" class="graf--p graf-after--h4">Not JavaScript, but still worth mentioning in a discussion about cutting out potentially-unnecessary technologies. <a href="https://developers.google.com/web/updates/2016/02/css-variables-why-should-you-care?hl=en" data-href="https://developers.google.com/web/updates/2016/02/css-variables-why-should-you-care?hl=en" class="markup--anchor markup--p-anchor" rel="nofollow">CSS variables</a> are the main selling point of CSS preprocessors such as Less and <a href="http://sass-lang.com/" data-href="http://sass-lang.com/" class="markup--anchor markup--p-anchor" rel="nofollow">Sass</a>. Like the other tools in this article, they have other helpful features, but for my uses CSS variables are the biggest draw. Without variables, maintaining a large-scale CSS codebase quickly becomes a headache.</p><pre name="b999" id="b999" class="graf--pre graf-after--p">:root {<br>  --main-bg-color: #0099cc;<br>}<br>.header {<br>  background-color: var(--main-bg-color);<br>}</pre><p name="726f" id="726f" class="graf--p graf-after--pre">That’s why I’m so excited to have them natively. The syntax is uglier than Less and Sass, and vanilla CSS doesn’t have nested clauses (justifiably, in my opinion), but it doesn’t matter. I can easily see myself forgoing Less/Sass entirely in future projects now.</p><figure name="989e" id="989e" class="graf--figure graf--iframe graf-after--p"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/011317df2ec730f67f1628a74de1f1d8?maxWidth=700" data-media-id="011317df2ec730f67f1628a74de1f1d8" frameborder="0"></iframe></div></figure><p name="6b2e" id="6b2e" class="graf--p graf-after--figure">Compared to preprocessors, native CSS variables also have the benefit of being fully live-editable in the Dev Tools, which Chrome has already implemented.</p><p name="156f" id="156f" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Who has it?</strong></p><ul class="postList"><li name="b9dd" id="b9dd" class="graf--li graf-after--p">Chrome 49+</li><li name="d2a3" id="d2a3" class="graf--li graf-after--li">Firefox 31+</li><li name="f9c8" id="f9c8" class="graf--li graf-after--li">Safari 9.3+</li></ul><p name="3270" id="3270" class="graf--p graf-after--li graf--last"><a href="https://dev.windows.com/en-us/microsoft-edge/platform/status/cssvariables" data-href="https://dev.windows.com/en-us/microsoft-edge/platform/status/cssvariables" class="markup--anchor markup--p-anchor" rel="nofollow">Microsoft has indicated that CSS variables are a “low” priority for Edge at this time.</a></p></div></div></section><section name="009e" class=" section--body"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="e7a2" id="e7a2" class="graf--h4 graf--first">Conclusion</h4><p name="85cf" id="85cf" class="graf--p graf-after--h4">It’s up to each developer (or engineering team) to decide whether the network cost, performance hits, and technical debt of third-party libraries and frameworks are worth their ease of use. That has always been and will continue to be the case. My goal today was to point out that very soon, pure JavaScript will be good enough for the entirety of the modern front-end stack. I’ve personally never been more excited to be working in this space. Thanks for reading!</p><p name="04f4" id="04f4" class="graf--p graf-after--p graf--last"><em class="markup--em markup--p-em">If you like this article, please recommend it by clicking the heart icon and by upvoting it on </em><a href="https://news.ycombinator.com/item?id=11068683" data-href="https://news.ycombinator.com/item?id=11068683" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">Hacker News</em></a><em class="markup--em markup--p-em"> and </em><a href="https://www.reddit.com/r/javascript/comments/44yw1t/choosing_vanilla_javascript_in_2016/" data-href="https://www.reddit.com/r/javascript/comments/44yw1t/choosing_vanilla_javascript_in_2016/" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">Reddit</em></a><em class="markup--em markup--p-em">.&nbsp;:D</em></p></div></div></section><section name="5543" class=" section--body section--last"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner layoutSingleColumn"><p name="f256" id="f256" class="graf--p graf--first graf--last"><a href="https://andrewrabon.com/" data-href="https://andrewrabon.com" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">Andrew</em></a><em class="markup--em markup--p-em"> is a software developer in Boston. Opinions in this article are his own and do not necessarily reflect that of his employer, </em><a href="http://www.nanigans.com/" data-href="http://www.nanigans.com" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">Nanigans</em></a><em class="markup--em markup--p-em">. Who, btw, </em><a href="http://www.nanigans.com/jobs/?p=search%3Fc%3DSoftware%2BEngineering%26p%3D0" data-href="http://www.nanigans.com/jobs/?p=search%3Fc%3DSoftware%2BEngineering%26p%3D0" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">are hiring!</em></a></p></div></div></section>