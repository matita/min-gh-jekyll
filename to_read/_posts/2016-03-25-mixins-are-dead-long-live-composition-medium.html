---
title: "Mixins Are Dead. Long Live Composition — Medium"
description: "When React 0.13 came out, everybody freaked out."
link: "https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.lssadvgom"
saved: "2016-03-25 11:14:22"
---
<section name="4772" class=" section--body section--first section--last"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner layoutSingleColumn"><h3 name="1039" id="1039" class="graf--h3 graf--first">Mixins Are Dead. Long Live Composition</h3><p name="a226" id="a226" class="graf--p graf-after--h3">When React 0.13 came out, everybody freaked out.<br>The introductory post made it clear that <strong class="markup--strong markup--p-strong">mixins are on their way out:</strong></p><blockquote name="6dec" id="6dec" class="graf--blockquote graf-after--p">Unfortunately, we will not launch any mixin support for ES6 classes in React. That would defeat the purpose of only using idiomatic JavaScript concepts.</blockquote><blockquote name="9ac4" id="9ac4" class="graf--blockquote graf-after--blockquote">There is no standard and universal way to define mixins in JavaScript. In fact, several features to support mixins were dropped from ES6 today. There are a lot of libraries with different semantics. We think that there should be one way of defining mixins that you can use for any JavaScript class. React just making another doesn’t help that effort.</blockquote><p name="1cf4" id="1cf4" class="graf--p graf-after--blockquote">One can read this as “mixins will come later” but the truth is that <strong class="markup--strong markup--p-strong">Sebastian Markbåge, </strong><a href="http://www.youtube.com/watch?v=4anAwXYqLG8" data-href="http://www.youtube.com/watch?v=4anAwXYqLG8" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">the great API terminator</strong></a><strong class="markup--strong markup--p-strong">, does not favor them:</strong></p><blockquote name="fc58" id="fc58" class="graf--blockquote graf-after--p"><a href="https://github.com/facebook/react/issues/1380#issue-31121026" data-href="https://github.com/facebook/react/issues/1380#issue-31121026" class="markup--anchor markup--blockquote-anchor" rel="nofollow">To be clear, mixins is an escape hatch to work around reusability limitations in the system. It’s not idiomatic React.</a> <a href="https://github.com/facebook/react/issues/1380#issuecomment-73958749" data-href="https://github.com/facebook/react/issues/1380#issuecomment-73958749" class="markup--anchor markup--blockquote-anchor" rel="nofollow">Making composition easier is a higher priority than making arbitrary mixins work.</a> <a href="https://twitter.com/sebmarkbage/status/571389309586051072" data-href="https://twitter.com/sebmarkbage/status/571389309586051072" class="markup--anchor markup--blockquote-anchor" rel="nofollow">I’ll focus on making composition easier so we can <strong class="markup--strong markup--blockquote-strong">get rid of mixins</strong>.</a></blockquote><p name="f624" id="f624" class="graf--p graf-after--blockquote">Why use mixins anyway? What problems do they solve? <strong class="markup--strong markup--p-strong">Can we solve these problems differently, without inheritance, and <em class="markup--em markup--p-em">super</em> woes?</strong></p><h4 name="0fdc" id="0fdc" class="graf--h4 graf-after--p">Utility Functions</h4><p name="bea5" id="bea5" class="graf--p graf-after--h4">This case is a no-brainer. If you use mixins to share utility functions, extract them to modules and import and use them directly.</p><h4 name="21d0" id="21d0" class="graf--h4 graf-after--p">Lifecycle Hooks and State Providers</h4><p name="8ef2" id="8ef2" class="graf--p graf-after--h4">This is the main use case for mixins. If you’re not very familiar with React’s mixin system, it tries to be smart and “merges” lifecycle hooks. If both the component and the several mixins it uses define the <em class="markup--em markup--p-em">componentDidMount</em> lifecycle hook, React will intelligently merge them so that each method will be called. Similarly, several mixins can contribute to the <em class="markup--em markup--p-em">getInitialState</em> result.</p><p name="40a2" id="40a2" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">In practice, this behaviour is the single thing that makes mixins useful.</strong> They can subscribe the component’s state to a Flux Store or they can work with its DOM node after it is updated. It’s absolutely necessary that any component extension mechanism has the access to the component’s lifecycle.</p><p name="9047" id="9047" class="graf--p graf-after--p">However mixins are fragile for a number of reasons:</p><ul class="postList"><li name="5236" id="5236" class="graf--li graf-after--p"><strong class="markup--strong markup--li-strong">The contract between a component and its mixins is implicit.</strong> The mixins often rely on certain methods being defined on the component, but there is no way to see that from the component’s definition.</li><li name="e3a5" id="e3a5" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">As you use more mixins in a single component, they begin to clash.</strong> For example, if you use something like <em class="markup--em markup--li-em">StoreMixin(SomeStore)</em> and you add another <em class="markup--em markup--li-em">StoreMixin(OtherStore)</em>, React will throw an exception because your component now has two versions of methods with the same names. Different mixins will also clash if they define the same state fields.</li><li name="5c22" id="5c22" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Mixins tend to add <em class="markup--em markup--li-em">more</em> state to your component whereas you should strive for less.</strong> You should read the excellent <a href="https://github.com/acdlite/flummox/blob/v3.5.1/docs/docs/guides/why-flux-component-is-better-than-flux-mixin.md" data-href="https://github.com/acdlite/flummox/blob/v3.5.1/docs/docs/guides/why-flux-component-is-better-than-flux-mixin.md" class="markup--anchor markup--li-anchor" rel="nofollow">Why Flux Component is better than Flux Mixin</a><strong class="markup--strong markup--li-strong"> </strong>essay by <a href="https://twitter.com/acdlite" data-href="https://twitter.com/acdlite" class="markup--anchor markup--li-anchor" rel="nofollow">Andrew Clark</a> on this topic.</li><li name="82ca" id="82ca" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Mixins complicate performance optimizations.</strong> If you define the <em class="markup--em markup--li-em">shouldComponentUpdate</em> method in your components (manually or via <em class="markup--em markup--li-em">PureRenderMixin</em>), you might have issues if some of the mixins need their own <em class="markup--em markup--li-em">shouldComponentUpdate</em> implementations to be taken into account. This can be solved by <a href="https://github.com/facebook/react/issues/2669" data-href="https://github.com/facebook/react/issues/2669" class="markup--anchor markup--li-anchor" rel="nofollow">adding even more “merging” magic</a>, but is it really the way forward?</li></ul><h4 name="fd19" id="fd19" class="graf--h4 graf-after--li">Enter Higher-Order Components</h4><p name="e220" id="e220" class="graf--p graf-after--h4">I first learned about this pattern from <a href="https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775" data-href="https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775" class="markup--anchor markup--p-anchor" rel="nofollow">a gist by Sebastian Markbåge</a>. The gist is a little bit cryptic if you’re not yet fully comfortable with ES6 syntax, so I’m going to use the “Flux Store mixin” example to explain it.</p><p name="278e" id="278e" class="graf--p graf-after--p">Note that this is just <strong class="markup--strong markup--p-strong">one possible way </strong>of replacing mixins with composition. See the notes at the end of the article for other approaches.</p><p name="8d42" id="8d42" class="graf--p graf-after--p">Suppose that you have a mixin that subscribes to the specified Flux Stores and triggers changes in component’s state. It might look like this:</p><pre name="75f1" id="75f1" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">function</strong> StoreMixin(...stores) {<br>  <strong class="markup--strong markup--pre-strong">var</strong> Mixin = {<br>    getInitialState() {<br>      <strong class="markup--strong markup--pre-strong">return</strong> <strong class="markup--strong markup--pre-strong">this</strong>.getStateFromStores(<strong class="markup--strong markup--pre-strong">this</strong>.props);<br>    },</pre><pre name="c008" id="c008" class="graf--pre graf-after--pre">    componentDidMount() {<br>      stores.forEach(store =&gt;<br>        store.addChangeListener(<strong class="markup--strong markup--pre-strong">this</strong>.handleStoresChanged)<br>      );</pre><pre name="4c6b" id="4c6b" class="graf--pre graf-after--pre">      <strong class="markup--strong markup--pre-strong">this</strong>.setState(<strong class="markup--strong markup--pre-strong">this</strong>.getStateFromStores(<strong class="markup--strong markup--pre-strong">this</strong>.props));<br>    },</pre><pre name="4c62" id="4c62" class="graf--pre graf-after--pre">    componentWillUnmount() {<br>      stores.forEach(store =&gt;<br>        store.removeChangeListener(<strong class="markup--strong markup--pre-strong">this</strong>.handleStoresChanged)<br>      );<br>    },</pre><pre name="fb51" id="fb51" class="graf--pre graf-after--pre">    handleStoresChanged() {<br>      if (<strong class="markup--strong markup--pre-strong">this</strong>.isMounted()) {<br>        <strong class="markup--strong markup--pre-strong">this</strong>.setState(this.getStateFromStores(<strong class="markup--strong markup--pre-strong">this</strong>.props));<br>      }<br>    }<br>  };</pre><pre name="2ad1" id="2ad1" class="graf--pre graf-after--pre">  <strong class="markup--strong markup--pre-strong">return</strong> Mixin;<br>}</pre><p name="0b4b" id="0b4b" class="graf--p graf-after--pre">To use it, the component adds <em class="markup--em markup--p-em">StoreMixin </em>to the <em class="markup--em markup--p-em">mixins</em> list and defines the <em class="markup--em markup--p-em">getStateFromStores(props)</em> function:</p><pre name="083d" id="083d" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">var</strong> UserProfilePage = React.createClass({<br>  mixins: [StoreMixin(UserStore)],</pre><pre name="d247" id="d247" class="graf--pre graf-after--pre">  propTypes: {<br>    userId: PropTypes.number.isRequired<br>  },</pre><pre name="9333" id="9333" class="graf--pre graf-after--pre">  getStateFromStores(props) {<br>    return {<br>      user: UserStore.get(props.userId);<br>    }<br>  }</pre><pre name="14bd" id="14bd" class="graf--pre graf-after--pre">  render() {<br>    var { user } = <strong class="markup--strong markup--pre-strong">this</strong>.state;<br>    return &lt;div&gt;{user ? user.name : 'Loading'}&lt;/div&gt;;<br>  }</pre><p name="96a9" id="96a9" class="graf--p graf-after--pre">How do we solve this without a mixin?</p><p name="da5b" id="da5b" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">A higher-order component is just a function that takes an existing component and returns another component that wraps it.</strong></p><p name="a3fd" id="a3fd" class="graf--p graf-after--p">Consider this implementation of <em class="markup--em markup--p-em">connectToStores</em>:</p><pre name="b3ae" id="b3ae" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">function</strong> connectToStores(Component, stores, getStateFromStores) {<br>  <strong class="markup--strong markup--pre-strong">const</strong> StoreConnection = React.createClass({<br>    getInitialState() {<br>      <strong class="markup--strong markup--pre-strong">return</strong> getStateFromStores(<strong class="markup--strong markup--pre-strong">this</strong>.props);<br>    },</pre><pre name="50b0" id="50b0" class="graf--pre graf-after--pre">    componentDidMount() {<br>      stores.forEach(store =&gt;<br>        store.addChangeListener(<strong class="markup--strong markup--pre-strong">this</strong>.handleStoresChanged)<br>      );<br>    },</pre><pre name="c030" id="c030" class="graf--pre graf-after--pre">    componentWillUnmount() {<br>      stores.forEach(store =&gt;<br>        store.removeChangeListener(<strong class="markup--strong markup--pre-strong">this</strong>.handleStoresChanged)<br>      );<br>    },</pre><pre name="edf9" id="edf9" class="graf--pre graf-after--pre">    handleStoresChanged() {<br>      if (<strong class="markup--strong markup--pre-strong">this</strong>.isMounted()) {<br>        <strong class="markup--strong markup--pre-strong">this</strong>.setState(getStateFromStores(<strong class="markup--strong markup--pre-strong">this</strong>.props));<br>      }<br>    },</pre><pre name="d24a" id="d24a" class="graf--pre graf-after--pre">    render() {<br>      <strong class="markup--strong markup--pre-strong">return</strong> &lt;Component {...<strong class="markup--strong markup--pre-strong">this</strong>.props} {...<strong class="markup--strong markup--pre-strong">this</strong>.state} /&gt;;<br>    }<br>  });</pre><pre name="1fb3" id="1fb3" class="graf--pre graf-after--pre">  return StoreConnection;<br>};</pre><p name="e3cc" id="e3cc" class="graf--p graf-after--pre">It looks a lot like the mixin, but instead of managing the component’s internal state, it wraps the component and passes some additional props to it. <strong class="markup--strong markup--p-strong">This way wrapper’s lifecycle hooks work without any special merging behavior, by the virtue of simple component nesting!</strong></p><p name="e20a" id="e20a" class="graf--p graf-after--p">It is then used like this:</p><pre name="e92a" id="e92a" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">var</strong> ProfilePage = React.createClass({<br>  propTypes: {<br>    userId: PropTypes.number.isRequired,<br>    user: PropTypes.object // note that user is now a prop<br>  },</pre><pre name="c1e4" id="c1e4" class="graf--pre graf-after--pre">  render() {<br>    var { user } = <strong class="markup--strong markup--pre-strong">this</strong>.props; // get user from props<br>    return &lt;div&gt;{user ? user.name : 'Loading'}&lt;/div&gt;;<br>  }<br>});</pre><pre name="afb2" id="afb2" class="graf--pre graf-after--pre">// Now wrap ProfilePage using a higher-order component:</pre><pre name="5b6f" id="5b6f" class="graf--pre graf-after--pre">ProfilePage = connectToStores(ProfilePage, [UserStore], props =&gt; ({<br>  user: UserStore.get(props.userId)<br>});</pre><p name="8401" id="8401" class="graf--p graf-after--pre">That’s it!</p><p name="8278" id="8278" class="graf--p graf-after--p"><span class="markup--quote markup--p-quote is-other" name="anon_803c108f9566" data-creator-ids="anon">The last missing piece is the handling of <em class="markup--em markup--p-em">componentWillReceiveProps. </em>You can find it in the <a href="https://github.com/gaearon/flux-react-router-example/blob/master/scripts/utils/connectToStores.js" data-href="https://github.com/gaearon/flux-react-router-example/blob/master/scripts/utils/connectToStores.js" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">connectToStores</em></strong></a> source code in the updated <a href="https://github.com/gaearon/flux-react-router-example/" data-href="https://github.com/gaearon/flux-react-router-example/" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">Flux React Router Example</strong></a><strong class="markup--strong markup--p-strong">.</strong></span></p><h4 name="dce3" id="dce3" class="graf--h4 graf-after--p">What’s Next</h4><p name="3617" id="3617" class="graf--p graf-after--h4">I plan to use higher-order components in the <a href="https://medium.com/@dan_abramov/the-future-of-drag-and-drop-apis-249dfea7a15f#3965" data-href="https://medium.com/@dan_abramov/the-future-of-drag-and-drop-apis-249dfea7a15f#3965" class="markup--anchor markup--p-anchor">next version of React DnD</a>.</p><p name="b778" id="b778" class="graf--p graf-after--p">They don’t solve <em class="markup--em markup--p-em">all </em>the<em class="markup--em markup--p-em"> </em>use cases for mixins, but come close. Don’t forget that the wrapper can pass arbitrary props to the wrapped component, even the callbacks. It’s possible that the higher-order components can be abused too, but unlike mixins they only rely on simple component composition instead of a bag of tricks and special cases.</p><p name="4922" id="4922" class="graf--p graf-after--p">There are things you can’t implement with higher-order components. For example, <em class="markup--em markup--p-em">PureRenderMixin</em> would be impossible to implement because the wrapper has no way to look into the wrapper component’s state and define its <em class="markup--em markup--p-em">shouldComponentUpdate</em>. However this is precisely the case where, in React 0.13, you might want to use a different base class, for example <em class="markup--em markup--p-em">PureComponent</em> that descends from <em class="markup--em markup--p-em">Component</em> and implements <em class="markup--em markup--p-em">shouldComponentUpdate</em>. Now <em class="markup--em markup--p-em">that’s</em> a valid use case for inheritance!</p><p name="524c" id="524c" class="graf--p graf-after--p">Operating on the DOM nodes may also be tricky because the wrapper component has no way to know when the child’s state updates. You can solve this by providing a <em class="markup--em markup--p-em">callback ref</em> (new in React 0.13) as one of the props to the composed component. It can then use <em class="markup--em markup--p-em">ref={this.props.someRef} </em>to notify the higher-order component about attaching and detaching a particular DOM node. The higher-order component can then use <em class="markup--em markup--p-em">React.findDOMNode</em> to work with that node.</p><figure name="6cdf" id="6cdf" class="graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked"><div class="aspectRatioPlaceholder-fill"></div><div class="progressiveMedia js-progressiveMedia graf-image is-canvasLoaded" data-image-id="1*QwHP9HYNykPro9RQzihWrA.png" data-width="490" data-height="347" data-scroll="native"><img src="https://cdn-images-2.medium.com/freeze/max/30/1*QwHP9HYNykPro9RQzihWrA.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail"><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-2.medium.com/max/800/1*QwHP9HYNykPro9RQzihWrA.png" src="https://cdn-images-2.medium.com/max/800/1*QwHP9HYNykPro9RQzihWrA.png"><noscript class="js-progressiveMedia-inner">&lt;img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-2.medium.com/max/800/1*QwHP9HYNykPro9RQzihWrA.png"&gt;</noscript></div></div></figure><h4 name="68c8" id="68c8" class="graf--h4 graf-after--figure">Other Approaches</h4><p name="8245" id="8245" class="graf--p graf-after--h4">There are <strong class="markup--strong markup--p-strong">other perfectly valid patterns for composition, such as composition right inside <em class="markup--em markup--p-em">render()</em></strong><em class="markup--em markup--p-em"> </em><a href="https://github.com/acdlite/flummox/blob/v3.5.1/docs/docs/api/fluxcomponent.md#custom-rendering" data-href="https://github.com/acdlite/flummox/blob/v3.5.1/docs/docs/api/fluxcomponent.md#custom-rendering" class="markup--anchor markup--p-anchor" rel="nofollow">as used in Flummox</a>. It is also based on nesting, but is less verbose than the higher-order components. This will be even easier in React 0.14, as it <a href="https://github.com/facebook/react/pull/3615" data-href="https://github.com/facebook/react/pull/3615" class="markup--anchor markup--p-anchor" rel="nofollow">switches to parent-based <em class="markup--em markup--p-em">context</em></a>.</p><p name="2bd3" id="2bd3" class="graf--p graf-after--p">You can always make your own mixin system, if you prefer to. By all means, you’re not limited to the higher order components! I wrote this article to shed more light on this approach. We’ll see what works best over the next months. I’m sure that the winning approaches will rely on composition instead of multiple inheritance (which is what mixins really are).</p><p name="be2b" id="be2b" class="graf--p graf-after--p">React is <a href="https://github.com/facebook/react/issues/3398" data-href="https://github.com/facebook/react/issues/3398" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">also tackling the problem of sideways data loading through a new API based on Observables</strong></a><strong class="markup--strong markup--p-strong">.</strong> We’ll see what 0.14 brings!</p><p name="9996" id="9996" class="graf--p graf-after--p">Follow <a href="http://twitter.com/dan_abramov" data-href="http://twitter.com/dan_abramov" class="markup--anchor markup--p-anchor" rel="nofollow">Dan Abramov</a> on Twitter</p><p name="8706" id="8706" class="graf--p graf-after--p graf--last">⚛</p></div></div></section>