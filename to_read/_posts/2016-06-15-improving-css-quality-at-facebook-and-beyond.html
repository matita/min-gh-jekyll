---
title: "Improving CSS quality at Facebook and beyond"
description: "Building on top of open source tools helped improve the quality of CSS at Facebook and set the stage for community-wide rules and guidelines."
link: "https://code.facebook.com/posts/879890885467584/improving-css-quality-at-facebook-and-beyond"
saved: "2016-06-15 17:07:56"
---
<p>With thousands of engineers working across a range of products at Facebook, we face some unique challenges when it comes to code quality.</p><p>Not only are we dealing with a large codebase, but things are also moving fast — new features are being added, existing ones are being improved, and things are being reorganized.</p><p>For CSS, this means having thousands of files that are in a continuous state of flux.</p><p>While we already try to ensure CSS code quality on different levels — through code reviews, style guidelines, and refactoring — unintentional mistakes can also be eliminated with static analysis before they're even committed.</p><p>Until recently, we used a homegrown CSS linter to catch basic errors and ensure consistent style. While it served its purpose well over the years, we wanted a more robust solution.</p><h2>Regex is not enough</h2><p>The old linter was essentially a number of regex search-and-replace rules. Properly parsing CSS is not a trivial problem, and accounting for custom vendor extensions and specification changes is even more challenging.</p><p>Here's an example of what old code might have looked like:</p><div class="_1c-v" id="u_0_5"><pre class="prettyprint prettyprinted"><span class="pln">preg_match_all</span><span class="pun">(</span><span class="pln">
 </span><span class="com">// This pattern matches [attr] selectors with no preceding selector.  </span><span class="pln">
    </span><span class="str">'/\/\*.*?\*\/|\{[^}]*\}|\s(\[[^\]]+\])/s'</span><span class="pun">,</span><span class="pln">
 $data</span><span class="pun">,</span><span class="pln">   
 $matches</span><span class="pun">,</span><span class="pln">   
 PREG_SET_ORDER </span><span class="pun">|</span><span class="pln"> PREG_OFFSET_CAPTURE</span><span class="pun">);</span><span class="pln">
 </span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$matches </span><span class="kwd">as</span><span class="pln"> $match</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
   </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">isset</span><span class="pun">(</span><span class="pln">$match</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
     raiseError</span><span class="pun">(...);</span><span class="pln">
   </span><span class="pun">}</span></pre></div><p>Maintaining rules with these kind of cryptic matchers is no fun. It was difficult to change and to understand. It was also a performance issue. For each rule, we had to iterate over the entire input again and again, matching various regular expressions.</p><h2>Abstract Syntax Tree</h2><p>We decided the new solution would be based on a real, spec-compliant CSS parser. Since the code would have to be syntactically valid for this type of parser to work, we could no longer treat our entire CSS codebase as a giant blob of text. This new approach would be a significant improvement in CSS code quality by catching typos that would have otherwise gone unnoticed and resulted in silently incorrect rendering or behavior.</p><p>What kind of behavior?</p><p>Some of the bits lurking in the shadows of our large codebase might have been things like:</p><div class="_1c-v" id="u_0_6"><pre class="prettyprint prettyprinted"><span class="pun">{</span><span class="pln">
  display</span><span class="pun">:</span><span class="pln"> none</span><span class="pun">:</span><span class="pln">
  background</span><span class="pun">-</span><span class="pln">color</span><span class="pun">:</span><span class="pln"> </span><span class="com">#8B1D3;</span><span class="pln">
  padding</span><span class="pun">:</span><span class="pln"> </span><span class="lit">10px</span><span class="pun">,</span><span class="lit">10px</span><span class="pun">,</span><span class="lit">0</span><span class="pun">,</span><span class="lit">0</span><span class="pun">;</span><span class="pln">
  opacity</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1.0f</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></pre></div><p>Can you spot the subtle differences? Typo in a property name, incorrect hex, wrong separators — browsers simply ignore all of these, which is far from the original developers' intent.</p><p>It didn't take long to realize that <a href="http://l.facebook.com/l.php?u=http%3A%2F%2Fpostcss.org%2F&amp;h=NAQEBtQ9e&amp;s=1" rel="nofollow" target="_blank" onmouseover="LinkshimAsyncLink.swap(this, &quot;http:\/\/postcss.org\/&quot;);" onclick="LinkshimAsyncLink.referrer_log(this, &quot;http:\/\/postcss.org\/&quot;, &quot;\/si\/ajax\/l\/render_linkshim_log\/?u=http\u00253A\u00252F\u00252Fpostcss.org\u00252F&amp;h=NAQEBtQ9e&amp;render_verification=0&amp;enc&amp;d&quot;);">PostCSS</a> would be a great tool for the job — a proper, standard-based CSS parser with an excellent modular architecture. We then selected <a href="http://l.facebook.com/l.php?u=http%3A%2F%2Fstylelint.io%2F&amp;h=UAQFcSPiI&amp;s=1" rel="nofollow" target="_blank" onmouseover="LinkshimAsyncLink.swap(this, &quot;http:\/\/stylelint.io\/&quot;);" onclick="LinkshimAsyncLink.referrer_log(this, &quot;http:\/\/stylelint.io\/&quot;, &quot;\/si\/ajax\/l\/render_linkshim_log\/?u=http\u00253A\u00252F\u00252Fstylelint.io\u00252F&amp;h=UAQFcSPiI&amp;render_verification=0&amp;enc&amp;d&quot;);">Stylelint</a> as our CSS linter. It's powered by PostCSS, just as flexible, and well-supported.</p><p>Similar to JavaScript-based parsers/linters like <a href="http://l.facebook.com/l.php?u=http%3A%2F%2Fesprima.org%2F&amp;h=9AQHoei-R&amp;s=1" rel="nofollow" target="_blank" onmouseover="LinkshimAsyncLink.swap(this, &quot;http:\/\/esprima.org\/&quot;);" onclick="LinkshimAsyncLink.referrer_log(this, &quot;http:\/\/esprima.org\/&quot;, &quot;\/si\/ajax\/l\/render_linkshim_log\/?u=http\u00253A\u00252F\u00252Fesprima.org\u00252F&amp;h=9AQHoei-R&amp;render_verification=0&amp;enc&amp;d&quot;);">Esprima</a> and <a href="http://l.facebook.com/l.php?u=http%3A%2F%2Feslint.org%2F&amp;h=HAQF7x2RV&amp;s=1" rel="nofollow" target="_blank" onmouseover="LinkshimAsyncLink.swap(this, &quot;http:\/\/eslint.org\/&quot;);" onclick="LinkshimAsyncLink.referrer_log(this, &quot;http:\/\/eslint.org\/&quot;, &quot;\/si\/ajax\/l\/render_linkshim_log\/?u=http\u00253A\u00252F\u00252Feslint.org\u00252F&amp;h=HAQF7x2RV&amp;render_verification=0&amp;enc&amp;d&quot;);">ESLint</a>, PostCSS and Stylelint give you access to the entire AST (Abstract Syntax Tree). AST makes it easy to access any nodes with any conditions: Are we using the right class names? Are we including correct abstractions? Are there any deprecated or non-supported extensions? Are there localization issues?</p><p>In this example, we're iterating over all declarations and finding any "text-transform: uppercase" pairs:</p><div class="_1c-v" id="u_0_7"><pre class="prettyprint prettyprinted"><span class="pln">root</span><span class="pun">.</span><span class="pln">walkDecls</span><span class="pun">(</span><span class="pln">node </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">node</span><span class="pun">.</span><span class="pln">prop </span><span class="pun">===</span><span class="pln"> </span><span class="str">'text-transform'</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> node</span><span class="pun">.</span><span class="pln">value </span><span class="pun">===</span><span class="pln"> </span><span class="str">'uppercase'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    report</span><span class="pun">({</span><span class="pln">
      </span><span class="pun">...</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">});</span></pre></div><p>We can even parse and deconstruct lower-level "functions" like <code>linear-gradient</code>. Here's a more involved example that finds the <code>linear-gradient</code> "function" and checks its first argument:</p><div class="_1c-v" id="u_0_8"><pre class="prettyprint prettyprinted"><span class="com">// disallow things like linear-gradient(top, blue, green) w. incorrect first valueroot.walkDecls(node =&gt; {</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> parsedValue </span><span class="pun">=</span><span class="pln"> styleParser</span><span class="pun">(</span><span class="pln">node</span><span class="pun">.</span><span class="pln">value</span><span class="pun">);</span><span class="pln">
  parsedValue</span><span class="pun">.</span><span class="pln">walk</span><span class="pun">(</span><span class="pln">valueNode </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">valueNode</span><span class="pun">.</span><span class="pln">type </span><span class="pun">===</span><span class="pln"> </span><span class="str">'function'</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> valueNode</span><span class="pun">.</span><span class="pln">value </span><span class="pun">===</span><span class="pln"> </span><span class="str">'linear-gradient'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> firstValueInGradient </span><span class="pun">=</span><span class="pln"> styleParser</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">(</span><span class="pln">valueNode</span><span class="pun">.</span><span class="pln">nodes</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]);</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">disallowedFirstValuesInGradient</span><span class="pun">.</span><span class="pln">indexOf</span><span class="pun">(</span><span class="pln">firstValueInGradient</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        report</span><span class="pun">({</span><span class="pln">
          </span><span class="pun">...</span><span class="pln">
        </span><span class="pun">});</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">});</span></pre></div><p>The code is relatively easy to understand and update. And all this will work no matter the formatting of CSS, and no matter where the rules and declarations are located (e.g., top level, inside media blocks, inside keyframe blocks).</p><p>It felt good to see the prowess of PostCSS and Stylelint crunching through our files. The two caught things like the typos mentioned earlier, values inside linear-gradients or keyframes, things like "! important" (which is apparently treated the same as "!important"), complex selectors, non-standard properties, and many more potential issues.</p><h2>Custom rules</h2><p>We were able to use a few of the existing Stylelint rules, such as <a href="https://www.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fstylelint%2Fstylelint%2Ftree%2Fmaster%2Fsrc%2Frules%2Fdeclaration-no-important&amp;h=CAQGvjHoN&amp;s=1" rel="nofollow" target="_blank" onmouseover="LinkshimAsyncLink.swap(this, &quot;https:\/\/github.com\/stylelint\/stylelint\/tree\/master\/src\/rules\/declaration-no-important&quot;);" onclick="LinkshimAsyncLink.referrer_log(this, &quot;https:\/\/github.com\/stylelint\/stylelint\/tree\/master\/src\/rules\/declaration-no-important&quot;, &quot;\/si\/ajax\/l\/render_linkshim_log\/?u=https\u00253A\u00252F\u00252Fgithub.com\u00252Fstylelint\u00252Fstylelint\u00252Ftree\u00252Fmaster\u00252Fsrc\u00252Frules\u00252Fdeclaration-no-important&amp;h=CAQGvjHoN&amp;render_verification=0&amp;enc&amp;d&quot;);">declaration-no-important</a>, <a href="https://www.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fstylelint%2Fstylelint%2Fblob%2Fmaster%2Fsrc%2Frules%2Fselector-no-universal%2FREADME.md&amp;h=SAQHcxsrr&amp;s=1" rel="nofollow" target="_blank" onmouseover="LinkshimAsyncLink.swap(this, &quot;https:\/\/github.com\/stylelint\/stylelint\/blob\/master\/src\/rules\/selector-no-universal\/README.md&quot;);" onclick="LinkshimAsyncLink.referrer_log(this, &quot;https:\/\/github.com\/stylelint\/stylelint\/blob\/master\/src\/rules\/selector-no-universal\/README.md&quot;, &quot;\/si\/ajax\/l\/render_linkshim_log\/?u=https\u00253A\u00252F\u00252Fgithub.com\u00252Fstylelint\u00252Fstylelint\u00252Fblob\u00252Fmaster\u00252Fsrc\u00252Frules\u00252Fselector-no-universal\u00252FREADME.md&amp;h=SAQHcxsrr&amp;render_verification=0&amp;enc&amp;d&quot;);">selector-no-universal</a>, and <a href="https://www.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fstylelint%2Fstylelint%2Ftree%2Fmaster%2Fsrc%2Frules%2Fselector-class-pattern&amp;h=YAQGfSst2&amp;s=1" rel="nofollow" target="_blank" onmouseover="LinkshimAsyncLink.swap(this, &quot;https:\/\/github.com\/stylelint\/stylelint\/tree\/master\/src\/rules\/selector-class-pattern&quot;);" onclick="LinkshimAsyncLink.referrer_log(this, &quot;https:\/\/github.com\/stylelint\/stylelint\/tree\/master\/src\/rules\/selector-class-pattern&quot;, &quot;\/si\/ajax\/l\/render_linkshim_log\/?u=https\u00253A\u00252F\u00252Fgithub.com\u00252Fstylelint\u00252Fstylelint\u00252Ftree\u00252Fmaster\u00252Fsrc\u00252Frules\u00252Fselector-class-pattern&amp;h=YAQGfSst2&amp;render_verification=0&amp;enc&amp;d&quot;);">selector-class-pattern</a>.</p><p>The custom rules were ported via a convenient <a href="http://l.facebook.com/l.php?u=http%3A%2F%2Fstylelint.io%2Fdeveloper-guide%2Fplugins%2F&amp;h=SAQHcxsrr&amp;s=1" rel="nofollow" target="_blank" onmouseover="LinkshimAsyncLink.swap(this, &quot;http:\/\/stylelint.io\/developer-guide\/plugins\/&quot;);" onclick="LinkshimAsyncLink.referrer_log(this, &quot;http:\/\/stylelint.io\/developer-guide\/plugins\/&quot;, &quot;\/si\/ajax\/l\/render_linkshim_log\/?u=http\u00253A\u00252F\u00252Fstylelint.io\u00252Fdeveloper-guide\u00252Fplugins\u00252F&amp;h=SAQHcxsrr&amp;render_verification=0&amp;enc&amp;d&quot;);">built-in plugin mechanism</a>. Some of what we have are:</p><ul><li>slow-css-properties to warn against performance-sensitive properties like opacity or box-shadow (just to be mindful of them)</li><li>filters-with-svg-files to warn against filters not being supported in Edge when referencing SVG files</li><li>use-variables to warn against values that could be replaced with existing constants (we use custom <code>var(...)</code> abstraction)</li><li>common-properties-whitelist to catch potentially nonexistent properties (i.e., typos)</li><li>mobile-flexbox to catch multi-value flex that's not supported in older mobile browsers</li><li>text-transform-uppercase to warn against "text-transform: uppercase" (which is not internationalization-friendly)</li></ul><p>We've also contributed some <a href="https://www.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fstylelint%2Fstylelint%2Fpull%2F675&amp;h=cAQEvADeV&amp;s=1" rel="nofollow" target="_blank" onmouseover="LinkshimAsyncLink.swap(this, &quot;https:\/\/github.com\/stylelint\/stylelint\/pull\/675&quot;);" onclick="LinkshimAsyncLink.referrer_log(this, &quot;https:\/\/github.com\/stylelint\/stylelint\/pull\/675&quot;, &quot;\/si\/ajax\/l\/render_linkshim_log\/?u=https\u00253A\u00252F\u00252Fgithub.com\u00252Fstylelint\u00252Fstylelint\u00252Fpull\u00252F675&amp;h=cAQEvADeV&amp;render_verification=0&amp;enc&amp;d&quot;);">rules</a> and <a href="https://www.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fstylelint%2Fstylelint%2Fpull%2F689&amp;h=yAQEoPU-J&amp;s=1" rel="nofollow" target="_blank" onmouseover="LinkshimAsyncLink.swap(this, &quot;https:\/\/github.com\/stylelint\/stylelint\/pull\/689&quot;);" onclick="LinkshimAsyncLink.referrer_log(this, &quot;https:\/\/github.com\/stylelint\/stylelint\/pull\/689&quot;, &quot;\/si\/ajax\/l\/render_linkshim_log\/?u=https\u00253A\u00252F\u00252Fgithub.com\u00252Fstylelint\u00252Fstylelint\u00252Fpull\u00252F689&amp;h=yAQEoPU-J&amp;render_verification=0&amp;enc&amp;d&quot;);">additions</a> back to Stylelint and are planning to eventually release all of them, either in a stand-alone repository or directly to Stylelint's existing lineup.</p><h2>Automatic replacement</h2><p>One important aspect of our linting process is auto-formatting. Linter has support for patching, and if something doesn't conform, it asks if you'd like things replaced according to the rule. This can be a powerful and time-saving concept. The last thing you want to do during a commit is to see lint errors, and then go back and fix all of them, across multiple files, especially if it's something as mundane as alphabetic rule reordering. It's usually better to let an auto-formatter do its job and save developers time.</p><p>Unfortunately, Stylelint doesn't have built-in auto-formatting (and, arguably, a linter shouldn't be concerned with such a task), so we had to reimplement a few of the existing Stylelint rules to add support for replacement via our existing infrastructure. Meanwhile, we're discussing potential generic changes to Stylelint to make this easier for all users in the future.</p><figure><img class="_253 img" src="https://scontent-mxp1-1.xx.fbcdn.net/t39.2365-6/13409339_811578745653310_267839981_n.jpg"></figure><br><h2>Test all the things</h2><p>One of the problems with our old linter was that we had no unit tests. This is concerning, since we're dealing with something that parses almost arbitrary text. When rewriting our linter to use Stylelint, we added tests for each single rule, ensuring that the rule catches the right things, ignores irrelevant things, and suggests the right replacements.</p><p>We used a trusted <a href="https://www.facebook.com/l.php?u=https%3A%2F%2Ffacebook.github.io%2Fjest%2F&amp;h=fAQGwGvtc&amp;s=1" rel="nofollow" target="_blank" onmouseover="LinkshimAsyncLink.swap(this, &quot;https:\/\/facebook.github.io\/jest\/&quot;);" onclick="LinkshimAsyncLink.referrer_log(this, &quot;https:\/\/facebook.github.io\/jest\/&quot;, &quot;\/si\/ajax\/l\/render_linkshim_log\/?u=https\u00253A\u00252F\u00252Ffacebook.github.io\u00252Fjest\u00252F&amp;h=fAQGwGvtc&amp;render_verification=0&amp;enc&amp;d&quot;);">Jest framework</a> (and worked with Stylelint to add <a href="https://www.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fstylelint%2Fstylelint%2Fissues%2F815&amp;h=nAQFSXSNS&amp;s=1" rel="nofollow" target="_blank" onmouseover="LinkshimAsyncLink.swap(this, &quot;https:\/\/github.com\/stylelint\/stylelint\/issues\/815&quot;);" onclick="LinkshimAsyncLink.referrer_log(this, &quot;https:\/\/github.com\/stylelint\/stylelint\/issues\/815&quot;, &quot;\/si\/ajax\/l\/render_linkshim_log\/?u=https\u00253A\u00252F\u00252Fgithub.com\u00252Fstylelint\u00252Fstylelint\u00252Fissues\u00252F815&amp;h=nAQFSXSNS&amp;render_verification=0&amp;enc&amp;d&quot;);">better support</a> for it ) and now have a nice set of easy-to-understand tests like this:</p><div class="_1c-v" id="u_0_9"><pre class="prettyprint prettyprinted"><span class="pln">test</span><span class="pun">.</span><span class="pln">ok</span><span class="pun">(</span><span class="str">'div { background-image: linear-gradient( 0deg, blue, green 40%, red ); }'</span><span class="pun">,</span><span class="pln"> 
  </span><span class="str">'linear gradient with valid syntax'</span><span class="pun">);</span><span class="pln">
test</span><span class="pun">.</span><span class="pln">notOk</span><span class="pun">(</span><span class="str">'a { background: linear-gradient(top, blue, green); }'</span><span class="pun">,</span><span class="pln"> 
  message</span><span class="pun">,</span><span class="pln"> 
    </span><span class="str">'linear-gradient with invalid syntax'</span><span class="pun">);</span></pre></div><br><h2>What's next</h2><p>This rewrite is only a first step toward higher-quality CSS. There are a number of useful rules we're planning to add (both built-in and custom ones) — all of them aimed to catch common errors, enforce best practices, and control code style conventions. We already do this with JavaScript (via ESLint) so there's no reason we shouldn't be able to do it with CSS.</p><p>The linter is already integrated with Phabricator, our code collaboration tool. The warnings/advice are shown right in the revision.</p><figure><img class="_253 img" src="https://scontent-mxp1-1.xx.fbcdn.net/l/t39.2365-6/13409338_199804860419310_2068595044_n.jpg"></figure><p>This makes the linting process an important step in the collaborate-and-commit workflow.</p><p>Another great thing about having a proper CSS parser is that it's possible to gather accurate statistics about the codebase. What are the least used properties/values? Perhaps they should be removed or replaced (sending fewer bytes over the wire). What are the most prevalent colors/font sizes/z-indexes? Perhaps they should be abstracted into reusable components and/or variables. What are the "heaviest" selectors? Perhaps there's a performance issue.</p><p>All of these could help improve both performance and maintenance.</p><h2>What about React and inline styles?</h2><p>It's worth mentioning the <a href="https://www.facebook.com/l.php?u=https%3A%2F%2Fspeakerdeck.com%2Fvjeux%2Freact-css-in-js&amp;h=LAQFW_nN6&amp;s=1" rel="nofollow" target="_blank" onmouseover="LinkshimAsyncLink.swap(this, &quot;https:\/\/speakerdeck.com\/vjeux\/react-css-in-js&quot;);" onclick="LinkshimAsyncLink.referrer_log(this, &quot;https:\/\/speakerdeck.com\/vjeux\/react-css-in-js&quot;, &quot;\/si\/ajax\/l\/render_linkshim_log\/?u=https\u00253A\u00252F\u00252Fspeakerdeck.com\u00252Fvjeux\u00252Freact-css-in-js&amp;h=LAQFW_nN6&amp;render_verification=0&amp;enc&amp;d&quot;);">CSS-in-JS concept</a> that's been gaining traction in the React community lately. As it stands now, a CSS linter is largely irrelevant in cases when CSS is defined in this less traditional approach. The linter is currently aimed at parsing traditional CSS files but could later be adapted to parse rules and declarations defined as objects in JS. PostCSS has a native JS API, so this should be fairly straightforward.</p><p>While we are currently exploring the CSS-in-JS approach at Facebook, it's still in its early experimental days, and we still have a large CSS codebase to maintain. Meanwhile, the linter serves its purpose.</p><h2>Working together</h2><p>We're excited to use open source tools and contribute back as much as we can. Hopefully, this will provide a solid set of modern rules and guidelines for everyone to use and collaborate on.</p><p>Thank you to the JS infra and webspeed teams, and any others who helped with the rewrite; David Clark and Richard Hallows of Stylelint, who were extremely helpful and responsive; as well as the entire community that made such fantastic tool as PostCSS possible.</p><p>This is truly a collaborative effort.</p><div class="_3f4b"><div class="fb-like _4hv9 fb_iframe_widget" data-href="https://code.facebook.com/posts/879890885467584/improving-css-quality-at-facebook-and-beyond/" data-send="true" data-show-faces="false" data-width="240" fb-xfbml-state="rendered" fb-iframe-plugin-query="app_id=1425766027653270&amp;container_width=718&amp;href=https%3A%2F%2Fcode.facebook.com%2Fposts%2F879890885467584%2Fimproving-css-quality-at-facebook-and-beyond%2F&amp;locale=it_IT&amp;sdk=joey&amp;send=true&amp;show_faces=false&amp;width=240"><span><iframe name="f25ed82c3b7ad" width="240px" height="1000px" frameborder="0" allowtransparency="true" allowfullscreen="true" scrolling="no" title="fb:like Facebook Social Plugin" src="https://www.facebook.com/v2.6/plugins/like.php?app_id=1425766027653270&amp;channel=https%3A%2F%2Fstaticxx.facebook.com%2Fconnect%2Fxd_arbiter.php%3Fversion%3D42%23cb%3Df216e712dc98a38%26domain%3Dcode.facebook.com%26origin%3Dhttps%253A%252F%252Fcode.facebook.com%252Ff9a52fe0757928%26relation%3Dparent.parent&amp;container_width=718&amp;href=https%3A%2F%2Fcode.facebook.com%2Fposts%2F879890885467584%2Fimproving-css-quality-at-facebook-and-beyond%2F&amp;locale=it_IT&amp;sdk=joey&amp;send=true&amp;show_faces=false&amp;width=240" class=""></iframe></span></div></div><div class="_4f8k"><h2>More to Read</h2><div class="_2-20 _2-21 _5mr _iuj _cql"><a href="https://code.facebook.com/posts/1031317120284314/safety-check-streamlining-deployment-around-the-world/"><h2>Safety Check: Streamlining deployment around the world<img class="_6f2 img" src="https://static.xx.fbcdn.net/rsrc.php/v2/yT/r/63tcwPLlO6z.png" alt="" title="Blog" width="12" height="12"></h2></a></div></div>