---
title: "Why you don’t need Socket.IO — Medium"
description: "Asynchronous communication between browsers and servers has come a very long way in the last 6 or 7 years."
link: "https://medium.com/@ivanderbyl/why-you-don-t-need-socket-io-6848f1c871cd#.cm6x3yonj"
saved: "2016-03-17 14:18:39"
---
<section name="5ab6" class=" section--body section--first section--last"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner layoutSingleColumn"><h3 name="93ce" id="93ce" class="graf--h3 graf--first">Why you don’t need Socket.IO</h3><p name="4ce7" id="4ce7" class="graf--p graf-after--h3">Asynchronous communication between browsers and servers has come a very long way in the last 6 or 7 years.</p><p name="d9b4" id="d9b4" class="graf--p graf-after--p">Back then, if you wanted to send a message asynchronously, you had to employ a bunch of hacks. These typically included some or all of the following:</p><ul class="postList"><li name="bf92" id="bf92" class="graf--li graf-after--p">Long polling</li><li name="96e6" id="96e6" class="graf--li graf-after--li">Flash Sockets (yes, Adobe Flash)</li><li name="9013" id="9013" class="graf--li graf-after--li"><em class="markup--em markup--li-em">Possible</em> upgrade to WebSockets</li></ul><p name="b569" id="b569" class="graf--p graf-after--li">These hacks were commonly employed as part of the very popular abstraction library, <em class="markup--em markup--p-em">Socket.IO</em>. Which was designed to initiate a connection with the lowest common denominator, then ‘upgrade’ the connection if the client supported a better feature.</p><p name="583b" id="583b" class="graf--p graf-after--p">This approach worked in nearly all cases, right back to browsers which nobody cares about anymore. However it came at the cost of expensive connection times, excess CPU/Memory/Garbage collection, extra resources to load, and a limited ability to support the developing standard features of the WebSockets protocol, which most notably until very recently, that meant <em class="markup--em markup--p-em">binary streams</em>.</p><h3 name="445e" id="445e" class="graf--h3 graf-after--p">Socket.IO</h3><p name="f573" id="f573" class="graf--p graf-after--h3">Over the years, Socket.IO became insanely popular, with over 25,000 stars on Github, and 5,000+ forks.</p><p name="5384" id="5384" class="graf--p graf-after--p">But the project always felt like it was trying to do too much. Is it a chat library? Is it a presence service? Is it a Socket? Is it a Sledgehammer? (I would have named it Sledgehammer.IO)</p><p name="bc7d" id="bc7d" class="graf--p graf-after--p">Nowadays Socket IO is actually two libraries. Engine.io which powers the socket abstractions, and connection management. And Socket.IO, which from what I can figure handles reconnection, event emitting, and message namespacing (kind of like chat rooms).</p><p name="ab7d" id="ab7d" class="graf--p graf-after--p">This is all excess when all you really need or want is a Socket.</p><h3 name="03f9" id="03f9" class="graf--h3 graf-after--p">Socket programming</h3><p name="71a9" id="71a9" class="graf--p graf-after--h3">Sockets are the basis for all connections over the internet. They are the end pieces which both a client and server terminate a connection with.</p><p name="909b" id="909b" class="graf--p graf-after--p">Low level sockets are essentially a stream of bytes. You write to one socket, and it appears byte for byte on the other socket’s read buffer.</p><p name="cc72" id="cc72" class="graf--p graf-after--p">When you make an HTTP request over the internet, it typically opens a socket connection to the server, and sends a request header, followed by an optional request body. This is just a stream of bytes, and it’s up the the receiving socket to know when the message is completely received. For HTTP this is handled by specifying the Length of the payload. The client can then just receive until it has Length bytes, then take those bytes and parse them as a request. To reply, it would then send back a response using the same semantics. Before closing the connection (unless instructed not to by a Keep-Alive header).</p><p name="a3f6" id="a3f6" class="graf--p graf-after--p">This is essentially what we call Framing messages. More on this later.</p><p name="38c1" id="38c1" class="graf--p graf-after--p">Some streams can be essentially endless and continue to write data, such as a video stream or audio stream. The underlying socket functions the same way, except messages are delineated using a special byte sequence, such as a null byte.</p><p name="8137" id="8137" class="graf--p graf-after--p">Up until relatively recently, the Web, as in browsers, didn’t have an equivalent to sockets. You could only make asynchronous requests for resources from the client, but the server never had a way to reply without the client asking it something. Around the time Node.js came along, the ability for the server to send out of band messages to the client was seen as incredibly useful, especially for an async server, which is why Socket.IO became so popular.</p><p name="b0da" id="b0da" class="graf--p graf-after--p">WebSockets were still very young, and there wasn’t yet a protocol standard which all browsers agreed to implement. It took a number of years, and many completing standards before in 2011 <a href="https://tools.ietf.org/html/rfc6455" data-href="https://tools.ietf.org/html/rfc6455" class="markup--anchor markup--p-anchor" rel="nofollow">RFC 6455</a> became the offical WebSocket protocol.</p><h3 name="8d56" id="8d56" class="graf--h3 graf-after--p"><strong class="markup--strong markup--h3-strong">WebSockets</strong></h3><p name="4db7" id="4db7" class="graf--p graf-after--h3">WebSockets aren’t <em class="markup--em markup--p-em">real</em> sockets. But they’re pretty damn close, and they work remarkably well.</p><p name="0c81" id="0c81" class="graf--p graf-after--p">The WebSocket protocol introduced a couple of extra attributes over the humble TCP socket. Firstly, in order to establish a connection, the client must request an “upgrade” from HTTP to WebSocket during the handshake process. This is initiated using a standard HTTP request to a given WebSocket endpoint. If the server supports WebSockets it will respond with a <em class="markup--em markup--p-em">HTTP/1.1 101 Switching Protocols</em> response, which instructs the client to keep the connection open, and use it as a stream.</p><p name="cc6a" id="cc6a" class="graf--p graf-after--p">After upgrading the connection, you’re free to send data down the socket in both directions, but here comes the second main difference: You’re not receiving a stream of bytes. All messages are framed automatically by the socket. So once one end finishes writing, the message will be available on the other end, and the socket will automatically decide how many bytes belong to this message. This makes WebSockets considerably easier to program with compared with regular sockets.</p><p name="9b6a" id="9b6a" class="graf--p graf-after--p">WebSockets also implement their own Ping/Pong semantics to keep the connection alive in the absence of any data being sent. This is something you typically have to account for with TCP sockets to ensure the other end hasn’t gone away.</p><p name="1bc9" id="1bc9" class="graf--p graf-after--p">Another useful feature of being able to establish a connection using HTTP is the ability to use HTTP authentication semantics for the socket, such as the Authorization header for Basic Auth or Bearer Token Auth.</p><h3 name="0de9" id="0de9" class="graf--h3 graf-after--p">Authentication strategies</h3><p name="aef4" id="aef4" class="graf--p graf-after--h3">I mentioned earlier that you can use standard HTTP authentication semantics, however sometimes you want to handle authentication at a later stage, or asynchronously.</p><p name="77e7" id="77e7" class="graf--p graf-after--p">A common pattern for this is to require that the first message over the socket is an authentication message, commonly called an “<em class="markup--em markup--p-em">authentication handshake</em>”. This is where the two parties exchange enough information about each other that they agree to keep the connection open.</p><p name="adc8" id="adc8" class="graf--p graf-after--p">Typically the client exchange with the server something like this:</p><pre name="4a5e" id="4a5e" class="graf--pre graf-after--p">CLIENT &gt; AUTH: secretpasscodeletmein<br>SERVER &lt; OK</pre><p name="2e62" id="2e62" class="graf--p graf-after--pre">The server — which is waiting for a message of type AUTH — would take the value and check its authenticity. If the value turns out to be correct, the connection stays open and server replies with some sort of <em class="markup--em markup--p-em">OK</em> message. Otherwise it simply closes the connection.</p><p name="ce87" id="ce87" class="graf--p graf-after--p">Because you can send whatever you like down the socket, it’s up to you to design a protocol which makes sense to both your server and client’s needs. This commonly would include a protocol negotiation message so you can support different features as your app develops without breaking older clients.</p><p name="83d6" id="83d6" class="graf--p graf-after--p">Or using an existing protocol, like <a href="https://stomp.github.io/" data-href="https://stomp.github.io/" class="markup--anchor markup--p-anchor" rel="nofollow">STOMP</a> or similar.</p><h3 name="3f8f" id="3f8f" class="graf--h3 graf-after--p">Use case: Chat</h3><p name="ca7f" id="ca7f" class="graf--p graf-after--h3">Socket IO’s initial attraction was that you could build a chat service which didn’t require continually polling the server for new messages, and anything you types could appear on multiple clients seemingly immediately.</p><p name="947c" id="947c" class="graf--p graf-after--p">To implement something like this with WebSockets is actually quite easy, and a lot more flexible than you might expect.</p><p name="f294" id="f294" class="graf--p graf-after--p">On the server side you need to handle clients connecting. These will represented as client objects, one for each connection which is open. You might have a flag to indicate a few required attributes about the client:</p><pre name="ce0d" id="ce0d" class="graf--pre graf-after--p">let client = {<br> id: 1,<br> isAuthenticated: true,<br> protocolVersion: 1,<br> connection: &lt;WebSocket Connection instance&gt;<br>}</pre><p name="559f" id="559f" class="graf--p graf-after--pre">Once authenticated you would set the isAuthenticated flag to true, as there will be some delay between the connection opening and the client sending the initial authentication sequence, and you’ll probably want to exclude this client from certain broadcasts.</p><p name="11c4" id="11c4" class="graf--p graf-after--p">To handle broadcasts to each client, either one-to-one, or one-to-many, you could create a Map, keyed on channel name, with a Set of values representing the IDs of each subscribed client.</p><p name="602b" id="602b" class="graf--p graf-after--p">How you establish a subscription is up to you, but it could be as simple as the client exchanging:</p><pre name="aae2" id="aae2" class="graf--pre graf-after--p">CLIENT &gt; SUB:general<br>SERVER &lt; OK</pre><pre name="2224" id="2224" class="graf--pre graf-after--pre">CLIENT &gt; UNSUB:general<br>SERVER &lt; OK</pre><p name="d08f" id="d08f" class="graf--p graf-after--pre">Then when you have a message to deliver — which could come from another client, internally, or an API request — you just need to look up all the clients associated with that channel, and send the message to each one. Example:</p><pre name="7ab4" id="7ab4" class="graf--pre graf-after--p">const subscriptions = new Map();<br>subscriptions.set(“general”, new Set())<br><br>// Subscribe a client to “general” channel.<br>subscriptions.get(“general”).add(client.id);<br><br>// Send message to a channel<br>subscriptions.get(“general”).forEach((clientId) =&gt; {<br>  clients.get(clientId).connection.send(message);<br>});<br><br>// Unsubscribe<br>subscriptions.get(“general”).delete(client.id);</pre><p name="0983" id="0983" class="graf--p graf-after--pre">See <a href="https://www.npmjs.com/package/websocket" data-href="https://www.npmjs.com/package/websocket" class="markup--anchor markup--p-anchor" rel="nofollow">https://www.npmjs.com/package/websocket</a> for a good starting point for a NodeJS server implementation, of if you’r using Go, <a href="https://github.com/gorilla/websocket" data-href="https://github.com/gorilla/websocket" class="markup--anchor markup--p-anchor" rel="nofollow">https://github.com/gorilla/websocket</a> is a good choice.</p><h3 name="efca" id="efca" class="graf--h3 graf-after--p">Compatibility with other clients</h3><p name="450a" id="450a" class="graf--p graf-after--h3">A major advantage of adopting WebSockets over Socket IO is interoperability with many different clients. There are standards compliant WebSocket client implementations in ObjectiveC, Javascript, Go, Haskell, Erlang, Ruby, Swift, and of course all major browsers. And this is the way it should be. You shouldn’t need to adapt your code to many different transports that do the same thing.</p><h3 name="f371" id="f371" class="graf--h3 graf-after--p">Thanks to Socket IO</h3><p name="a85e" id="a85e" class="graf--p graf-after--h3">Without Socket IO a lot of very cool and useful apps would never have been built, and without the hard work of hundreds of contributors the library wouldn’t be were it is today. But I think its time to upgrade to pure WebSockets, and remove the extra cruft from your app.</p><h3 name="8f5d" id="8f5d" class="graf--h3 graf-after--p">Conclusion</h3><p name="3f16" id="3f16" class="graf--p graf-after--h3 graf--last">If you’re a browser and you need a socket, use WebSockets. <a href="http://caniuse.com/#search=websockets" data-href="http://caniuse.com/#search=websockets" class="markup--anchor markup--p-anchor" rel="nofollow">All major browsers have supported</a> WebSockets for years, so go forth and be async.</p></div></div></section>